use crate::bus::Tick;
use crate::ntsc::*;

#[cfg(feature = "serde_support")]
use serde::{Deserialize, Deserializer, Serialize, Serializer};

#[cfg(feature = "web_time")]
use web_time::SystemTime;

#[cfg(not(feature = "web_time"))]
use std::time::SystemTime;

pub type Rgb = [u8; 3];
pub type Yuv = [f32; 3];

#[derive(Default, Debug, Copy, Clone, PartialEq)]
#[allow(non_camel_case_types)]
pub enum DisplayMode {
    #[default]
    DEFAULT,
    NTSC,
    MONO_WHITE,
    MONO_NTSC,
    MONO_GREEN,
    MONO_AMBER,
    RGB,
}

#[derive(Debug)]
#[cfg_attr(feature = "serde_support", derive(Serialize, Deserialize))]
pub struct Video {
    #[cfg_attr(
        feature = "serde_support",
        serde(
            serialize_with = "serialize_display_mode",
            deserialize_with = "deserialize_display_mode"
        )
    )]
    #[cfg_attr(feature = "serde_support", serde(default))]
    pub display_mode: DisplayMode,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_frame"))]
    pub frame: Vec<u8>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_video_main"))]
    pub video_main: Vec<u8>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_video_aux"))]
    pub video_aux: Vec<u8>,

    #[cfg_attr(feature = "serde_support", serde(default))]
    pub _80storeon: bool,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_text"))]
    lut_text: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_text_2e"))]
    lut_text_2e: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_hires"))]
    lut_hires: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_text_pal"))]
    lut_text_pal: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_text_2e_pal"))]
    lut_text_2e_pal: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_lut_hires_pal"))]
    lut_hires_pal: Vec<usize>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_video_cache"))]
    video_cache: Vec<u32>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_video_reparse"))]
    video_reparse: Vec<u8>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_video_dirty"))]
    video_dirty: Vec<u8>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_ntsc_decoder"))]
    ntsc_decoder: Vec<Yuv>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_chroma_dhgr"))]
    chroma_dhgr: Vec<Vec<Rgb>>,

    #[cfg_attr(feature = "serde_support", serde(skip_serializing))]
    #[cfg_attr(feature = "serde_support", serde(default = "default_chroma_hgr"))]
    chroma_hgr: Vec<Vec<Rgb>>,

    #[cfg_attr(feature = "serde_support", serde(default = "default_luma_bandwidth"))]
    pub luma_bandwidth: f32,

    #[cfg_attr(feature = "serde_support", serde(default = "default_chroma_bandwidth"))]
    pub chroma_bandwidth: f32,

    #[cfg_attr(feature = "serde_support", serde(default = "default_cycle_field"))]
    cycle_field: usize,

    #[cfg_attr(
        feature = "serde_support",
        serde(deserialize_with = "deserialize_cycles")
    )]
    cycles: usize,

    graphics_mode: bool,
    mixed_mode: bool,
    lores_mode: bool,
    vid80_mode: bool,
    video_page2: bool,
    dhires_mode: bool,
    altchar: bool,
    blink: bool,
    blink_time: u64,
    video_latch: u8,
    prev_video_data: u8,
    apple2e: bool,

    #[cfg_attr(feature = "serde_support", serde(default))]
    apple2e_enh: bool,

    #[cfg_attr(feature = "serde_support", serde(default))]
    apple2c: bool,

    video_50hz: bool,
    mono_mode: bool,
    rgb_mode: u8,

    #[cfg_attr(feature = "serde_support", serde(default))]
    scanline: bool,

    #[cfg_attr(feature = "serde_support", serde(default))]
    pub skip_update: bool,

    #[cfg_attr(feature = "serde_support", serde(default))]
    pub color_burst: bool,

    #[cfg_attr(feature = "serde_support", serde(default))]
    pub mac_lc_dlgr: bool,
}

impl Tick for Video {
    fn tick(&mut self) {
        self.cycles += 1;

        if self.cycles >= self.cycle_field {
            self.cycles = 0;
        }

        if !self.skip_update {
            self.update_video();
        }
    }
}

const TEXT_LEN: usize = 0x400;
const HIRES_LEN: usize = 0x2000;
const CYCLES_PER_ROW: usize = 65;
const CYCLES_PER_HBL: usize = 25;
const CYCLES_PER_FIELD_60HZ: usize = 17030;
const CYCLES_PER_FIELD_50HZ: usize = 20280;

// Flash frequency is 60 Hz / 32 (267ms) or 50 Hz / 32 (320 ms)
const BLINK_PERIOD_60HZ: usize = 267;
const BLINK_PERIOD_50HZ: usize = 320;

// hires colors
/*
const COLOR_ORANGE:  Rgb = [0xff, 0x66, 0x00];
const COLOR_GREEN:  Rgb = [0x11, 0xdd, 0x00];
const COLOR_BLUE:  Rgb = [0x09, 0x2a, 0xff];
const COLOR_VIOLET:  Rgb = [0xdd, 0x22, 0xdd];
const COLOR_WHITE:  Rgb = [0xff, 0xff, 0xff];
const COLOR_BLACK:  Rgb = [0x00, 0x00, 0x00];
*/

// lores colors
// Based on GS Colors
/*
const COLOR_MAGENTA:  Rgb = [0xdd, 0x00, 0x33];
const COLOR_DARK_BLUE:  Rgb = [0x00, 0x00, 0x99];
const COLOR_DARK_GREEN:  Rgb = [0x00, 0x77, 0x22];
const COLOR_DARK_GRAY:  Rgb = [0x55, 0x55, 0x55];
const COLOR_MEDIUM_BLUE:  Rgb = [0x22, 0x22, 0xff];
const COLOR_LIGHT_BLUE:  Rgb = [0x66, 0xaa, 0xff];
const COLOR_BROWN:  Rgb = [0x88, 0x55, 0x00];
const COLOR_LIGHT_GRAY:  Rgb = [0xaa, 0xaa, 0xaa];
const COLOR_PINK:  Rgb = [0xff, 0x99, 0x88];
const COLOR_YELLOW:  Rgb = [0xff, 0xff, 0x00];
const COLOR_AQUAMARINE:  Rgb = [0x44, 0xff, 0x99];
*/

// Color is derived from NTSC simulation
pub const COLOR_BLACK: Rgb = [0x00, 0x00, 0x00];
pub const COLOR_MAGENTA: Rgb = [0xcd, 0x00, 0x75];
pub const COLOR_DARK_BLUE: Rgb = [0x21, 0x1d, 0xff];
pub const COLOR_VIOLET: Rgb = [0xef, 0x0a, 0xff];
pub const COLOR_DARK_GREEN: Rgb = [0x00, 0x92, 0x09];
pub const COLOR_DARK_GRAY: Rgb = [0x7f, 0x7f, 0x7f];
pub const COLOR_MEDIUM_BLUE: Rgb = [0x00, 0xb0, 0xff];
pub const COLOR_LIGHT_BLUE: Rgb = [0xa0, 0x9d, 0xff];
pub const COLOR_BROWN: Rgb = [0x5d, 0x61, 0x00];
pub const COLOR_ORANGE: Rgb = [0xff, 0x4e, 0x00];
pub const COLOR_LIGHT_GRAY: Rgb = [0x7f, 0x7f, 0x7f];
pub const COLOR_PINK: Rgb = [0xff, 0x6c, 0xf5];
pub const COLOR_GREEN: Rgb = [0x0f, 0xf4, 0x00];
pub const COLOR_YELLOW: Rgb = [0xdd, 0xe1, 0x00];
pub const COLOR_AQUAMARINE: Rgb = [0x31, 0xff, 0x89];
pub const COLOR_WHITE: Rgb = [0xff, 0xff, 0xff];

const LORES_COLORS: [Rgb; 16] = [
    COLOR_BLACK,
    COLOR_MAGENTA,
    COLOR_DARK_BLUE,
    COLOR_VIOLET,
    COLOR_DARK_GREEN,
    COLOR_DARK_GRAY,
    COLOR_MEDIUM_BLUE,
    COLOR_LIGHT_BLUE,
    COLOR_BROWN,
    COLOR_ORANGE,
    COLOR_LIGHT_GRAY,
    COLOR_PINK,
    COLOR_GREEN,
    COLOR_YELLOW,
    COLOR_AQUAMARINE,
    COLOR_WHITE,
];

const _HIRES_COLORS: [Rgb; 16] = [
    COLOR_BLACK,
    COLOR_VIOLET,
    COLOR_GREEN,
    COLOR_WHITE,
    COLOR_BLACK,
    COLOR_MEDIUM_BLUE,
    COLOR_ORANGE,
    COLOR_WHITE,
    COLOR_BLACK,
    COLOR_MEDIUM_BLUE,
    COLOR_ORANGE,
    COLOR_WHITE,
    COLOR_BLACK,
    COLOR_VIOLET,
    COLOR_GREEN,
    COLOR_WHITE,
];

const DHIRES_COLORS: [Rgb; 16] = [
    COLOR_BLACK,
    COLOR_DARK_BLUE,
    COLOR_DARK_GREEN,
    COLOR_MEDIUM_BLUE,
    COLOR_BROWN,
    COLOR_LIGHT_GRAY,
    COLOR_GREEN,
    COLOR_AQUAMARINE,
    COLOR_MAGENTA,
    COLOR_VIOLET,
    COLOR_DARK_GRAY,
    COLOR_LIGHT_BLUE,
    COLOR_ORANGE,
    COLOR_PINK,
    COLOR_YELLOW,
    COLOR_WHITE,
];

const CHAR_APPLE2_ROM: [u8; 2048] = [
    0x00, 0x1c, 0x22, 0x2a, 0x2e, 0x2c, 0x20, 0x1e, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1c,
    0x00, 0x3c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x3e,
    0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1e, 0x20, 0x20, 0x20, 0x26, 0x22, 0x1e,
    0x00, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c,
    0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22,
    0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3e, 0x00, 0x22, 0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22,
    0x00, 0x22, 0x22, 0x32, 0x2a, 0x26, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x2a, 0x24, 0x1a,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x28, 0x24, 0x22, 0x00, 0x1c, 0x22, 0x20, 0x1c, 0x02, 0x22, 0x1c,
    0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c,
    0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x22, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x22,
    0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08,
    0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3e,
    0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x3e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3e,
    0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08,
    0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x3e, 0x14, 0x3e, 0x14, 0x14,
    0x00, 0x08, 0x1e, 0x28, 0x1c, 0x0a, 0x3c, 0x08, 0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06,
    0x00, 0x10, 0x28, 0x28, 0x10, 0x2a, 0x24, 0x1a, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08,
    0x00, 0x08, 0x2a, 0x1c, 0x08, 0x1c, 0x2a, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
    0x00, 0x1c, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x1c, 0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1c,
    0x00, 0x1c, 0x22, 0x02, 0x0c, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x02, 0x04, 0x0c, 0x02, 0x22, 0x1c,
    0x00, 0x04, 0x0c, 0x14, 0x24, 0x3e, 0x04, 0x04, 0x00, 0x3e, 0x20, 0x3c, 0x02, 0x02, 0x22, 0x1c,
    0x00, 0x0e, 0x10, 0x20, 0x3c, 0x22, 0x22, 0x1c, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10,
    0x00, 0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1e, 0x02, 0x04, 0x38,
    0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x10,
    0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00,
    0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x1c, 0x22, 0x04, 0x08, 0x08, 0x00, 0x08,
    0x80, 0x9c, 0xa2, 0xaa, 0xae, 0xac, 0xa0, 0x9e, 0x80, 0x88, 0x94, 0xa2, 0xa2, 0xbe, 0xa2, 0xa2,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa2, 0xa2, 0xbc, 0x80, 0x9c, 0xa2, 0xa0, 0xa0, 0xa0, 0xa2, 0x9c,
    0x80, 0xbc, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xbc, 0x80, 0xbe, 0xa0, 0xa0, 0xbc, 0xa0, 0xa0, 0xbe,
    0x80, 0xbe, 0xa0, 0xa0, 0xbc, 0xa0, 0xa0, 0xa0, 0x80, 0x9e, 0xa0, 0xa0, 0xa0, 0xa6, 0xa2, 0x9e,
    0x80, 0xa2, 0xa2, 0xa2, 0xbe, 0xa2, 0xa2, 0xa2, 0x80, 0x9c, 0x88, 0x88, 0x88, 0x88, 0x88, 0x9c,
    0x80, 0x82, 0x82, 0x82, 0x82, 0x82, 0xa2, 0x9c, 0x80, 0xa2, 0xa4, 0xa8, 0xb0, 0xa8, 0xa4, 0xa2,
    0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xbe, 0x80, 0xa2, 0xb6, 0xaa, 0xaa, 0xa2, 0xa2, 0xa2,
    0x80, 0xa2, 0xa2, 0xb2, 0xaa, 0xa6, 0xa2, 0xa2, 0x80, 0x9c, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x9c,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa0, 0xa0, 0xa0, 0x80, 0x9c, 0xa2, 0xa2, 0xa2, 0xaa, 0xa4, 0x9a,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa8, 0xa4, 0xa2, 0x80, 0x9c, 0xa2, 0xa0, 0x9c, 0x82, 0xa2, 0x9c,
    0x80, 0xbe, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x9c,
    0x80, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x94, 0x88, 0x80, 0xa2, 0xa2, 0xa2, 0xaa, 0xaa, 0xb6, 0xa2,
    0x80, 0xa2, 0xa2, 0x94, 0x88, 0x94, 0xa2, 0xa2, 0x80, 0xa2, 0xa2, 0x94, 0x88, 0x88, 0x88, 0x88,
    0x80, 0xbe, 0x82, 0x84, 0x88, 0x90, 0xa0, 0xbe, 0x80, 0xbe, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xbe,
    0x80, 0x80, 0xa0, 0x90, 0x88, 0x84, 0x82, 0x80, 0x80, 0xbe, 0x86, 0x86, 0x86, 0x86, 0x86, 0xbe,
    0x80, 0x80, 0x80, 0x88, 0x94, 0xa2, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xbe,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x88,
    0x80, 0x94, 0x94, 0x94, 0x80, 0x80, 0x80, 0x80, 0x80, 0x94, 0x94, 0xbe, 0x94, 0xbe, 0x94, 0x94,
    0x80, 0x88, 0x9e, 0xa8, 0x9c, 0x8a, 0xbc, 0x88, 0x80, 0xb0, 0xb2, 0x84, 0x88, 0x90, 0xa6, 0x86,
    0x80, 0x90, 0xa8, 0xa8, 0x90, 0xaa, 0xa4, 0x9a, 0x80, 0x88, 0x88, 0x88, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x88, 0x90, 0xa0, 0xa0, 0xa0, 0x90, 0x88, 0x80, 0x88, 0x84, 0x82, 0x82, 0x82, 0x84, 0x88,
    0x80, 0x88, 0xaa, 0x9c, 0x88, 0x9c, 0xaa, 0x88, 0x80, 0x80, 0x88, 0x88, 0xbe, 0x88, 0x88, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x88, 0x90, 0x80, 0x80, 0x80, 0x80, 0xbe, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x80, 0x80, 0x82, 0x84, 0x88, 0x90, 0xa0, 0x80,
    0x80, 0x9c, 0xa2, 0xa6, 0xaa, 0xb2, 0xa2, 0x9c, 0x80, 0x88, 0x98, 0x88, 0x88, 0x88, 0x88, 0x9c,
    0x80, 0x9c, 0xa2, 0x82, 0x8c, 0x90, 0xa0, 0xbe, 0x80, 0xbe, 0x82, 0x84, 0x8c, 0x82, 0xa2, 0x9c,
    0x80, 0x84, 0x8c, 0x94, 0xa4, 0xbe, 0x84, 0x84, 0x80, 0xbe, 0xa0, 0xbc, 0x82, 0x82, 0xa2, 0x9c,
    0x80, 0x8e, 0x90, 0xa0, 0xbc, 0xa2, 0xa2, 0x9c, 0x80, 0xbe, 0x82, 0x84, 0x88, 0x90, 0x90, 0x90,
    0x80, 0x9c, 0xa2, 0xa2, 0x9c, 0xa2, 0xa2, 0x9c, 0x80, 0x9c, 0xa2, 0xa2, 0x9e, 0x82, 0x84, 0xb8,
    0x80, 0x80, 0x80, 0x88, 0x80, 0x88, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x80, 0x88, 0x88, 0x90,
    0x80, 0x84, 0x88, 0x90, 0xa0, 0x90, 0x88, 0x84, 0x80, 0x80, 0x80, 0xbe, 0x80, 0xbe, 0x80, 0x80,
    0x80, 0x90, 0x88, 0x84, 0x82, 0x84, 0x88, 0x90, 0x80, 0x9c, 0xa2, 0x84, 0x88, 0x88, 0x80, 0x88,
    0x00, 0x1c, 0x22, 0x2a, 0x2e, 0x2c, 0x20, 0x1e, 0x00, 0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3c, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1c,
    0x00, 0x3c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x3e,
    0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1e, 0x20, 0x20, 0x20, 0x26, 0x22, 0x1e,
    0x00, 0x22, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x22, 0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c,
    0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x22, 0x24, 0x28, 0x30, 0x28, 0x24, 0x22,
    0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3e, 0x00, 0x22, 0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22,
    0x00, 0x22, 0x22, 0x32, 0x2a, 0x26, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x2a, 0x24, 0x1a,
    0x00, 0x3c, 0x22, 0x22, 0x3c, 0x28, 0x24, 0x22, 0x00, 0x1c, 0x22, 0x20, 0x1c, 0x02, 0x22, 0x1c,
    0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c,
    0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x22, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x22,
    0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08,
    0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3e,
    0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x3e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x3e,
    0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x08,
    0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x14, 0x3e, 0x14, 0x3e, 0x14, 0x14,
    0x00, 0x08, 0x1e, 0x28, 0x1c, 0x0a, 0x3c, 0x08, 0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06,
    0x00, 0x10, 0x28, 0x28, 0x10, 0x2a, 0x24, 0x1a, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08,
    0x00, 0x08, 0x2a, 0x1c, 0x08, 0x1c, 0x2a, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
    0x00, 0x1c, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x1c, 0x00, 0x08, 0x18, 0x08, 0x08, 0x08, 0x08, 0x1c,
    0x00, 0x1c, 0x22, 0x02, 0x0c, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x02, 0x04, 0x0c, 0x02, 0x22, 0x1c,
    0x00, 0x04, 0x0c, 0x14, 0x24, 0x3e, 0x04, 0x04, 0x00, 0x3e, 0x20, 0x3c, 0x02, 0x02, 0x22, 0x1c,
    0x00, 0x0e, 0x10, 0x20, 0x3c, 0x22, 0x22, 0x1c, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10,
    0x00, 0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1e, 0x02, 0x04, 0x38,
    0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x10,
    0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00,
    0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x1c, 0x22, 0x04, 0x08, 0x08, 0x00, 0x08,
    0x80, 0x9c, 0xa2, 0xaa, 0xae, 0xac, 0xa0, 0x9e, 0x80, 0x88, 0x94, 0xa2, 0xa2, 0xbe, 0xa2, 0xa2,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa2, 0xa2, 0xbc, 0x80, 0x9c, 0xa2, 0xa0, 0xa0, 0xa0, 0xa2, 0x9c,
    0x80, 0xbc, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xbc, 0x80, 0xbe, 0xa0, 0xa0, 0xbc, 0xa0, 0xa0, 0xbe,
    0x80, 0xbe, 0xa0, 0xa0, 0xbc, 0xa0, 0xa0, 0xa0, 0x80, 0x9e, 0xa0, 0xa0, 0xa0, 0xa6, 0xa2, 0x9e,
    0x80, 0xa2, 0xa2, 0xa2, 0xbe, 0xa2, 0xa2, 0xa2, 0x80, 0x9c, 0x88, 0x88, 0x88, 0x88, 0x88, 0x9c,
    0x80, 0x82, 0x82, 0x82, 0x82, 0x82, 0xa2, 0x9c, 0x80, 0xa2, 0xa4, 0xa8, 0xb0, 0xa8, 0xa4, 0xa2,
    0x80, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xbe, 0x80, 0xa2, 0xb6, 0xaa, 0xaa, 0xa2, 0xa2, 0xa2,
    0x80, 0xa2, 0xa2, 0xb2, 0xaa, 0xa6, 0xa2, 0xa2, 0x80, 0x9c, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x9c,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa0, 0xa0, 0xa0, 0x80, 0x9c, 0xa2, 0xa2, 0xa2, 0xaa, 0xa4, 0x9a,
    0x80, 0xbc, 0xa2, 0xa2, 0xbc, 0xa8, 0xa4, 0xa2, 0x80, 0x9c, 0xa2, 0xa0, 0x9c, 0x82, 0xa2, 0x9c,
    0x80, 0xbe, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x9c,
    0x80, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0x94, 0x88, 0x80, 0xa2, 0xa2, 0xa2, 0xaa, 0xaa, 0xb6, 0xa2,
    0x80, 0xa2, 0xa2, 0x94, 0x88, 0x94, 0xa2, 0xa2, 0x80, 0xa2, 0xa2, 0x94, 0x88, 0x88, 0x88, 0x88,
    0x80, 0xbe, 0x82, 0x84, 0x88, 0x90, 0xa0, 0xbe, 0x80, 0xbe, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xbe,
    0x80, 0x80, 0xa0, 0x90, 0x88, 0x84, 0x82, 0x80, 0x80, 0xbe, 0x86, 0x86, 0x86, 0x86, 0x86, 0xbe,
    0x80, 0x80, 0x80, 0x88, 0x94, 0xa2, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xbe,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x88, 0x88, 0x88, 0x88, 0x80, 0x88,
    0x80, 0x94, 0x94, 0x94, 0x80, 0x80, 0x80, 0x80, 0x80, 0x94, 0x94, 0xbe, 0x94, 0xbe, 0x94, 0x94,
    0x80, 0x88, 0x9e, 0xa8, 0x9c, 0x8a, 0xbc, 0x88, 0x80, 0xb0, 0xb2, 0x84, 0x88, 0x90, 0xa6, 0x86,
    0x80, 0x90, 0xa8, 0xa8, 0x90, 0xaa, 0xa4, 0x9a, 0x80, 0x88, 0x88, 0x88, 0x80, 0x80, 0x80, 0x80,
    0x80, 0x88, 0x90, 0xa0, 0xa0, 0xa0, 0x90, 0x88, 0x80, 0x88, 0x84, 0x82, 0x82, 0x82, 0x84, 0x88,
    0x80, 0x88, 0xaa, 0x9c, 0x88, 0x9c, 0xaa, 0x88, 0x80, 0x80, 0x88, 0x88, 0xbe, 0x88, 0x88, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x88, 0x90, 0x80, 0x80, 0x80, 0x80, 0xbe, 0x80, 0x80, 0x80,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x80, 0x80, 0x82, 0x84, 0x88, 0x90, 0xa0, 0x80,
    0x80, 0x9c, 0xa2, 0xa6, 0xaa, 0xb2, 0xa2, 0x9c, 0x80, 0x88, 0x98, 0x88, 0x88, 0x88, 0x88, 0x9c,
    0x80, 0x9c, 0xa2, 0x82, 0x8c, 0x90, 0xa0, 0xbe, 0x80, 0xbe, 0x82, 0x84, 0x8c, 0x82, 0xa2, 0x9c,
    0x80, 0x84, 0x8c, 0x94, 0xa4, 0xbe, 0x84, 0x84, 0x80, 0xbe, 0xa0, 0xbc, 0x82, 0x82, 0xa2, 0x9c,
    0x80, 0x8e, 0x90, 0xa0, 0xbc, 0xa2, 0xa2, 0x9c, 0x80, 0xbe, 0x82, 0x84, 0x88, 0x90, 0x90, 0x90,
    0x80, 0x9c, 0xa2, 0xa2, 0x9c, 0xa2, 0xa2, 0x9c, 0x80, 0x9c, 0xa2, 0xa2, 0x9e, 0x82, 0x84, 0xb8,
    0x80, 0x80, 0x80, 0x88, 0x80, 0x88, 0x80, 0x80, 0x80, 0x80, 0x80, 0x88, 0x80, 0x88, 0x88, 0x90,
    0x80, 0x84, 0x88, 0x90, 0xa0, 0x90, 0x88, 0x84, 0x80, 0x80, 0x80, 0xbe, 0x80, 0xbe, 0x80, 0x80,
    0x80, 0x90, 0x88, 0x84, 0x82, 0x84, 0x88, 0x90, 0x80, 0x9c, 0xa2, 0x84, 0x88, 0x88, 0x80, 0x88,
];

const CHAR_APPLE2E_ROM: [u8; 4096] = [
    0xc7, 0xbb, 0xab, 0xa3, 0xa7, 0xbf, 0xc3, 0xff, 0xef, 0xd7, 0xbb, 0xbb, 0x83, 0xbb, 0xbb, 0xff,
    0x87, 0xbb, 0xbb, 0x87, 0xbb, 0xbb, 0x87, 0xff, 0xc7, 0xbb, 0xbf, 0xbf, 0xbf, 0xbb, 0xc7, 0xff,
    0x87, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0x87, 0xff, 0x83, 0xbf, 0xbf, 0x87, 0xbf, 0xbf, 0x83, 0xff,
    0x83, 0xbf, 0xbf, 0x87, 0xbf, 0xbf, 0xbf, 0xff, 0xc3, 0xbf, 0xbf, 0xbf, 0xb3, 0xbb, 0xc3, 0xff,
    0xbb, 0xbb, 0xbb, 0x83, 0xbb, 0xbb, 0xbb, 0xff, 0xc7, 0xef, 0xef, 0xef, 0xef, 0xef, 0xc7, 0xff,
    0xfb, 0xfb, 0xfb, 0xfb, 0xfb, 0xbb, 0xc7, 0xff, 0xbb, 0xb7, 0xaf, 0x9f, 0xaf, 0xb7, 0xbb, 0xff,
    0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0xbf, 0x83, 0xff, 0xbb, 0x93, 0xab, 0xab, 0xbb, 0xbb, 0xbb, 0xff,
    0xbb, 0xbb, 0x9b, 0xab, 0xb3, 0xbb, 0xbb, 0xff, 0xc7, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xc7, 0xff,
    0x87, 0xbb, 0xbb, 0x87, 0xbf, 0xbf, 0xbf, 0xff, 0xc7, 0xbb, 0xbb, 0xbb, 0xab, 0xb7, 0xcb, 0xff,
    0x87, 0xbb, 0xbb, 0x87, 0xaf, 0xb7, 0xbb, 0xff, 0xc7, 0xbb, 0xbf, 0xc7, 0xfb, 0xbb, 0xc7, 0xff,
    0x83, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xff, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xc7, 0xff,
    0xbb, 0xbb, 0xbb, 0xbb, 0xbb, 0xd7, 0xef, 0xff, 0xbb, 0xbb, 0xbb, 0xab, 0xab, 0x93, 0xbb, 0xff,
    0xbb, 0xbb, 0xd7, 0xef, 0xd7, 0xbb, 0xbb, 0xff, 0xbb, 0xbb, 0xd7, 0xef, 0xef, 0xef, 0xef, 0xff,
    0x83, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0x83, 0xff, 0x83, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0x83, 0xff,
    0xff, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xff, 0xff, 0x83, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0x83, 0xff,
    0xff, 0xff, 0xef, 0xd7, 0xbb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xef, 0xef, 0xef, 0xef, 0xff, 0xef, 0xff,
    0xd7, 0xd7, 0xd7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd7, 0xd7, 0x83, 0xd7, 0x83, 0xd7, 0xd7, 0xff,
    0xef, 0xc3, 0xaf, 0xc7, 0xeb, 0x87, 0xef, 0xff, 0x9f, 0x9b, 0xf7, 0xef, 0xdf, 0xb3, 0xf3, 0xff,
    0xdf, 0xaf, 0xaf, 0xdf, 0xab, 0xb7, 0xcb, 0xff, 0xef, 0xef, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xef, 0xdf, 0xbf, 0xbf, 0xbf, 0xdf, 0xef, 0xff, 0xef, 0xf7, 0xfb, 0xfb, 0xfb, 0xf7, 0xef, 0xff,
    0xef, 0xab, 0xc7, 0xef, 0xc7, 0xab, 0xef, 0xff, 0xff, 0xef, 0xef, 0x83, 0xef, 0xef, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xef, 0xef, 0xdf, 0xff, 0xff, 0xff, 0xff, 0x83, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xfb, 0xf7, 0xef, 0xdf, 0xbf, 0xff, 0xff,
    0xc7, 0xbb, 0xb3, 0xab, 0x9b, 0xbb, 0xc7, 0xff, 0xef, 0xcf, 0xef, 0xef, 0xef, 0xef, 0xc7, 0xff,
    0xc7, 0xbb, 0xfb, 0xe7, 0xdf, 0xbf, 0x83, 0xff, 0x83, 0xfb, 0xf7, 0xe7, 0xfb, 0xbb, 0xc7, 0xff,
    0xf7, 0xe7, 0xd7, 0xb7, 0x83, 0xf7, 0xf7, 0xff, 0x83, 0xbf, 0x87, 0xfb, 0xfb, 0xbb, 0xc7, 0xff,
    0xe3, 0xdf, 0xbf, 0x87, 0xbb, 0xbb, 0xc7, 0xff, 0x83, 0xfb, 0xf7, 0xef, 0xdf, 0xdf, 0xdf, 0xff,
    0xc7, 0xbb, 0xbb, 0xc7, 0xbb, 0xbb, 0xc7, 0xff, 0xc7, 0xbb, 0xbb, 0xc3, 0xfb, 0xf7, 0x8f, 0xff,
    0xff, 0xff, 0xef, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xef, 0xef, 0xdf, 0xff,
    0xf7, 0xef, 0xdf, 0xbf, 0xdf, 0xef, 0xf7, 0xff, 0xff, 0xff, 0x83, 0xff, 0x83, 0xff, 0xff, 0xff,
    0xdf, 0xef, 0xf7, 0xfb, 0xf7, 0xef, 0xdf, 0xff, 0xc7, 0xbb, 0xf7, 0xef, 0xef, 0xff, 0xef, 0xff,
    0x08, 0x10, 0x6c, 0xfe, 0xfc, 0xfc, 0x7e, 0x6c, 0x08, 0x10, 0x6c, 0x82, 0x84, 0x84, 0x52, 0x6c,
    0x00, 0x00, 0x40, 0x60, 0x70, 0x78, 0x6c, 0x42, 0xfe, 0x44, 0x28, 0x10, 0x10, 0x28, 0x54, 0xfe,
    0x00, 0x02, 0x04, 0x88, 0x50, 0x20, 0x20, 0x00, 0xfe, 0xfc, 0xfa, 0x36, 0xae, 0xde, 0xde, 0xfe,
    0x0e, 0x06, 0x7e, 0x8c, 0x9e, 0x0c, 0xfc, 0x40, 0x00, 0x18, 0xe0, 0x00, 0xe0, 0x30, 0x10, 0x0e,
    0x10, 0x20, 0x40, 0xfe, 0x40, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54,
    0x10, 0x10, 0x10, 0x10, 0x92, 0x54, 0x38, 0x10, 0x10, 0x38, 0x54, 0x92, 0x10, 0x10, 0x10, 0x10,
    0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x22, 0x62, 0xfe, 0x60, 0x20,
    0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xc8, 0x18, 0x38, 0x7e, 0x38, 0x18, 0x08, 0xf6,
    0x26, 0x30, 0x38, 0xfc, 0x38, 0x30, 0x20, 0xde, 0x02, 0x12, 0x10, 0xfe, 0x7c, 0x38, 0x12, 0x02,
    0x02, 0x12, 0x38, 0x7c, 0xfe, 0x10, 0x12, 0x02, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xfe, 0x10, 0x08, 0x04, 0xfe, 0x04, 0x08, 0x10, 0x00,
    0x54, 0xaa, 0x54, 0xaa, 0x54, 0xaa, 0x54, 0xaa, 0xaa, 0x54, 0xaa, 0x54, 0xaa, 0x54, 0xaa, 0x54,
    0x00, 0x7c, 0x82, 0x80, 0x80, 0x80, 0xfe, 0x00, 0x00, 0x00, 0xfc, 0x02, 0x02, 0x02, 0xfe, 0x00,
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
    0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x28, 0x28, 0xee, 0x00, 0xee, 0x28, 0x28, 0x00,
    0xfe, 0x02, 0x02, 0x32, 0x32, 0x02, 0x02, 0xfe, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
    0xdf, 0xef, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xfb, 0xc3, 0xbb, 0xc3, 0xff,
    0xbf, 0xbf, 0x87, 0xbb, 0xbb, 0xbb, 0x87, 0xff, 0xff, 0xff, 0xc3, 0xbf, 0xbf, 0xbf, 0xc3, 0xff,
    0xfb, 0xfb, 0xc3, 0xbb, 0xbb, 0xbb, 0xc3, 0xff, 0xff, 0xff, 0xc7, 0xbb, 0x83, 0xbf, 0xc3, 0xff,
    0xe7, 0xdb, 0xdf, 0x87, 0xdf, 0xdf, 0xdf, 0xff, 0xff, 0xff, 0xc7, 0xbb, 0xbb, 0xc3, 0xfb, 0xc7,
    0xbf, 0xbf, 0x87, 0xbb, 0xbb, 0xbb, 0xbb, 0xff, 0xef, 0xff, 0xcf, 0xef, 0xef, 0xef, 0xc7, 0xff,
    0xf7, 0xff, 0xe7, 0xf7, 0xf7, 0xf7, 0xb7, 0xcf, 0xbf, 0xbf, 0xbb, 0xb7, 0x8f, 0xb7, 0xbb, 0xff,
    0xcf, 0xef, 0xef, 0xef, 0xef, 0xef, 0xc7, 0xff, 0xff, 0xff, 0x93, 0xab, 0xab, 0xab, 0xbb, 0xff,
    0xff, 0xff, 0x87, 0xbb, 0xbb, 0xbb, 0xbb, 0xff, 0xff, 0xff, 0xc7, 0xbb, 0xbb, 0xbb, 0xc7, 0xff,
    0xff, 0xff, 0x87, 0xbb, 0xbb, 0x87, 0xbf, 0xbf, 0xff, 0xff, 0xc3, 0xbb, 0xbb, 0xc3, 0xfb, 0xfb,
    0xff, 0xff, 0xa3, 0x9f, 0xbf, 0xbf, 0xbf, 0xff, 0xff, 0xff, 0xc3, 0xbf, 0xc7, 0xfb, 0x87, 0xff,
    0xdf, 0xdf, 0x87, 0xdf, 0xdf, 0xdb, 0xe7, 0xff, 0xff, 0xff, 0xbb, 0xbb, 0xbb, 0xb3, 0xcb, 0xff,
    0xff, 0xff, 0xbb, 0xbb, 0xbb, 0xd7, 0xef, 0xff, 0xff, 0xff, 0xbb, 0xbb, 0xab, 0xab, 0x93, 0xff,
    0xff, 0xff, 0xbb, 0xd7, 0xef, 0xd7, 0xbb, 0xff, 0xff, 0xff, 0xbb, 0xbb, 0xbb, 0xc3, 0xfb, 0xc7,
    0xff, 0xff, 0x83, 0xf7, 0xef, 0xdf, 0x83, 0xff, 0xe3, 0xcf, 0xcf, 0x9f, 0xcf, 0xcf, 0xe3, 0xff,
    0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0x8f, 0xe7, 0xe7, 0xf3, 0xe7, 0xe7, 0x8f, 0xff,
    0xcb, 0xa7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xab, 0xd7, 0xab, 0xd7, 0xab, 0xff, 0xff,
    0x38, 0x44, 0x54, 0x5c, 0x58, 0x40, 0x3c, 0x00, 0x10, 0x28, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x44, 0x44, 0x78, 0x00, 0x38, 0x44, 0x40, 0x40, 0x40, 0x44, 0x38, 0x00,
    0x78, 0x44, 0x44, 0x44, 0x44, 0x44, 0x78, 0x00, 0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x7c, 0x00,
    0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x00, 0x3c, 0x40, 0x40, 0x40, 0x4c, 0x44, 0x3c, 0x00,
    0x44, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x44, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x38, 0x00, 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44, 0x00,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c, 0x00, 0x44, 0x6c, 0x54, 0x54, 0x44, 0x44, 0x44, 0x00,
    0x44, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x44, 0x00, 0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x40, 0x00, 0x38, 0x44, 0x44, 0x44, 0x54, 0x48, 0x34, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x50, 0x48, 0x44, 0x00, 0x38, 0x44, 0x40, 0x38, 0x04, 0x44, 0x38, 0x00,
    0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x44, 0x44, 0x44, 0x44, 0x44, 0x28, 0x10, 0x00, 0x44, 0x44, 0x44, 0x54, 0x54, 0x6c, 0x44, 0x00,
    0x44, 0x44, 0x28, 0x10, 0x28, 0x44, 0x44, 0x00, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00,
    0x7c, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7c, 0x00, 0x7c, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7c, 0x00,
    0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x7c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x7c, 0x00,
    0x00, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00,
    0x28, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x28, 0x7c, 0x28, 0x7c, 0x28, 0x28, 0x00,
    0x10, 0x3c, 0x50, 0x38, 0x14, 0x78, 0x10, 0x00, 0x60, 0x64, 0x08, 0x10, 0x20, 0x4c, 0x0c, 0x00,
    0x20, 0x50, 0x50, 0x20, 0x54, 0x48, 0x34, 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x20, 0x40, 0x40, 0x40, 0x20, 0x10, 0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x08, 0x10, 0x00,
    0x10, 0x54, 0x38, 0x10, 0x38, 0x54, 0x10, 0x00, 0x00, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00,
    0x38, 0x44, 0x4c, 0x54, 0x64, 0x44, 0x38, 0x00, 0x10, 0x30, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00,
    0x38, 0x44, 0x04, 0x18, 0x20, 0x40, 0x7c, 0x00, 0x7c, 0x04, 0x08, 0x18, 0x04, 0x44, 0x38, 0x00,
    0x08, 0x18, 0x28, 0x48, 0x7c, 0x08, 0x08, 0x00, 0x7c, 0x40, 0x78, 0x04, 0x04, 0x44, 0x38, 0x00,
    0x1c, 0x20, 0x40, 0x78, 0x44, 0x44, 0x38, 0x00, 0x7c, 0x04, 0x08, 0x10, 0x20, 0x20, 0x20, 0x00,
    0x38, 0x44, 0x44, 0x38, 0x44, 0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x3c, 0x04, 0x08, 0x70, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x10, 0x10, 0x20, 0x00,
    0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x00, 0x00,
    0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x00, 0x38, 0x44, 0x08, 0x10, 0x10, 0x00, 0x10, 0x00,
    0x38, 0x44, 0x54, 0x5c, 0x58, 0x40, 0x3c, 0x00, 0x10, 0x28, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x44, 0x44, 0x78, 0x00, 0x38, 0x44, 0x40, 0x40, 0x40, 0x44, 0x38, 0x00,
    0x78, 0x44, 0x44, 0x44, 0x44, 0x44, 0x78, 0x00, 0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x7c, 0x00,
    0x7c, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x00, 0x3c, 0x40, 0x40, 0x40, 0x4c, 0x44, 0x3c, 0x00,
    0x44, 0x44, 0x44, 0x7c, 0x44, 0x44, 0x44, 0x00, 0x38, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x38, 0x00, 0x44, 0x48, 0x50, 0x60, 0x50, 0x48, 0x44, 0x00,
    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7c, 0x00, 0x44, 0x6c, 0x54, 0x54, 0x44, 0x44, 0x44, 0x00,
    0x44, 0x44, 0x64, 0x54, 0x4c, 0x44, 0x44, 0x00, 0x38, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x40, 0x00, 0x38, 0x44, 0x44, 0x44, 0x54, 0x48, 0x34, 0x00,
    0x78, 0x44, 0x44, 0x78, 0x50, 0x48, 0x44, 0x00, 0x38, 0x44, 0x40, 0x38, 0x04, 0x44, 0x38, 0x00,
    0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x44, 0x44, 0x44, 0x44, 0x44, 0x28, 0x10, 0x00, 0x44, 0x44, 0x44, 0x54, 0x54, 0x6c, 0x44, 0x00,
    0x44, 0x44, 0x28, 0x10, 0x28, 0x44, 0x44, 0x00, 0x44, 0x44, 0x28, 0x10, 0x10, 0x10, 0x10, 0x00,
    0x7c, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7c, 0x00, 0x7c, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7c, 0x00,
    0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x7c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x7c, 0x00,
    0x00, 0x00, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe,
    0x20, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x04, 0x3c, 0x44, 0x3c, 0x00,
    0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x78, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x40, 0x40, 0x3c, 0x00,
    0x04, 0x04, 0x3c, 0x44, 0x44, 0x44, 0x3c, 0x00, 0x00, 0x00, 0x38, 0x44, 0x7c, 0x40, 0x3c, 0x00,
    0x18, 0x24, 0x20, 0x78, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x3c, 0x04, 0x38,
    0x40, 0x40, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00, 0x10, 0x00, 0x30, 0x10, 0x10, 0x10, 0x38, 0x00,
    0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x48, 0x30, 0x40, 0x40, 0x44, 0x48, 0x70, 0x48, 0x44, 0x00,
    0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x38, 0x00, 0x00, 0x00, 0x6c, 0x54, 0x54, 0x54, 0x44, 0x00,
    0x00, 0x00, 0x78, 0x44, 0x44, 0x44, 0x44, 0x00, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
    0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x40, 0x40, 0x00, 0x00, 0x3c, 0x44, 0x44, 0x3c, 0x04, 0x04,
    0x00, 0x00, 0x5c, 0x60, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x3c, 0x40, 0x38, 0x04, 0x78, 0x00,
    0x20, 0x20, 0x78, 0x20, 0x20, 0x24, 0x18, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x4c, 0x34, 0x00,
    0x00, 0x00, 0x44, 0x44, 0x44, 0x28, 0x10, 0x00, 0x00, 0x00, 0x44, 0x44, 0x54, 0x54, 0x6c, 0x00,
    0x00, 0x00, 0x44, 0x28, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x44, 0x44, 0x44, 0x3c, 0x04, 0x38,
    0x00, 0x00, 0x7c, 0x08, 0x10, 0x20, 0x7c, 0x00, 0x1c, 0x30, 0x30, 0x60, 0x30, 0x30, 0x1c, 0x00,
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x70, 0x18, 0x18, 0x0c, 0x18, 0x18, 0x70, 0x00,
    0x34, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x28, 0x54, 0x28, 0x54, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x88, 0x22, 0x80, 0x80, 0x00, 0x00,
    0x40, 0x40, 0x44, 0x11, 0x40, 0x40, 0x00, 0x00, 0xc0, 0xc0, 0xcc, 0x33, 0xc0, 0xc0, 0x00, 0x00,
    0x20, 0x20, 0x22, 0x88, 0x20, 0x20, 0x00, 0x00, 0xa0, 0xa0, 0xaa, 0xaa, 0xa0, 0xa0, 0x00, 0x00,
    0x60, 0x60, 0x66, 0x99, 0x60, 0x60, 0x00, 0x00, 0xe0, 0xe0, 0xee, 0xbb, 0xe0, 0xe0, 0x00, 0x00,
    0x10, 0x10, 0x11, 0x44, 0x10, 0x10, 0x00, 0x00, 0x90, 0x90, 0x99, 0x66, 0x90, 0x90, 0x00, 0x00,
    0x50, 0x50, 0x55, 0x55, 0x50, 0x50, 0x00, 0x00, 0xd0, 0xd0, 0xdd, 0x77, 0xd0, 0xd0, 0x00, 0x00,
    0x30, 0x30, 0x33, 0xcc, 0x30, 0x30, 0x00, 0x00, 0xb0, 0xb0, 0xbb, 0xee, 0xb0, 0xb0, 0x00, 0x00,
    0x70, 0x70, 0x77, 0xdd, 0x70, 0x70, 0x00, 0x00, 0xf0, 0xf0, 0xff, 0xff, 0xf0, 0xf0, 0x00, 0x00,
    0x08, 0x08, 0x00, 0x00, 0x08, 0x08, 0x88, 0x22, 0x88, 0x88, 0x88, 0x22, 0x88, 0x88, 0x88, 0x22,
    0x48, 0x48, 0x44, 0x11, 0x48, 0x48, 0x88, 0x22, 0xc8, 0xc8, 0xcc, 0x33, 0xc8, 0xc8, 0x88, 0x22,
    0x28, 0x28, 0x22, 0x88, 0x28, 0x28, 0x88, 0x22, 0xa8, 0xa8, 0xaa, 0xaa, 0xa8, 0xa8, 0x88, 0x22,
    0x68, 0x68, 0x66, 0x99, 0x68, 0x68, 0x88, 0x22, 0xe8, 0xe8, 0xee, 0xbb, 0xe8, 0xe8, 0x88, 0x22,
    0x18, 0x18, 0x11, 0x44, 0x18, 0x18, 0x88, 0x22, 0x98, 0x98, 0x99, 0x66, 0x98, 0x98, 0x88, 0x22,
    0x58, 0x58, 0x55, 0x55, 0x58, 0x58, 0x88, 0x22, 0xd8, 0xd8, 0xdd, 0x77, 0xd8, 0xd8, 0x88, 0x22,
    0x38, 0x38, 0x33, 0xcc, 0x38, 0x38, 0x88, 0x22, 0xb8, 0xb8, 0xbb, 0xee, 0xb8, 0xb8, 0x88, 0x22,
    0x78, 0x78, 0x77, 0xdd, 0x78, 0x78, 0x88, 0x22, 0xf8, 0xf8, 0xff, 0xff, 0xf8, 0xf8, 0x88, 0x22,
    0x04, 0x04, 0x00, 0x00, 0x04, 0x04, 0x44, 0x11, 0x84, 0x84, 0x88, 0x22, 0x84, 0x84, 0x44, 0x11,
    0x44, 0x44, 0x44, 0x11, 0x44, 0x44, 0x44, 0x11, 0xc4, 0xc4, 0xcc, 0x33, 0xc4, 0xc4, 0x44, 0x11,
    0x24, 0x24, 0x22, 0x88, 0x24, 0x24, 0x44, 0x11, 0xa4, 0xa4, 0xaa, 0xaa, 0xa4, 0xa4, 0x44, 0x11,
    0x64, 0x64, 0x66, 0x99, 0x64, 0x64, 0x44, 0x11, 0xe4, 0xe4, 0xee, 0xbb, 0xe4, 0xe4, 0x44, 0x11,
    0x14, 0x14, 0x11, 0x44, 0x14, 0x14, 0x44, 0x11, 0x94, 0x94, 0x99, 0x66, 0x94, 0x94, 0x44, 0x11,
    0x54, 0x54, 0x55, 0x55, 0x54, 0x54, 0x44, 0x11, 0xd4, 0xd4, 0xdd, 0x77, 0xd4, 0xd4, 0x44, 0x11,
    0x34, 0x34, 0x33, 0xcc, 0x34, 0x34, 0x44, 0x11, 0xb4, 0xb4, 0xbb, 0xee, 0xb4, 0xb4, 0x44, 0x11,
    0x74, 0x74, 0x77, 0xdd, 0x74, 0x74, 0x44, 0x11, 0xf4, 0xf4, 0xff, 0xff, 0xf4, 0xf4, 0x44, 0x11,
    0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x0c, 0xcc, 0x33, 0x8c, 0x8c, 0x88, 0x22, 0x8c, 0x8c, 0xcc, 0x33,
    0x4c, 0x4c, 0x44, 0x11, 0x4c, 0x4c, 0xcc, 0x33, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc, 0xcc, 0x33,
    0x2c, 0x2c, 0x22, 0x88, 0x2c, 0x2c, 0xcc, 0x33, 0xac, 0xac, 0xaa, 0xaa, 0xac, 0xac, 0xcc, 0x33,
    0x6c, 0x6c, 0x66, 0x99, 0x6c, 0x6c, 0xcc, 0x33, 0xec, 0xec, 0xee, 0xbb, 0xec, 0xec, 0xcc, 0x33,
    0x1c, 0x1c, 0x11, 0x44, 0x1c, 0x1c, 0xcc, 0x33, 0x9c, 0x9c, 0x99, 0x66, 0x9c, 0x9c, 0xcc, 0x33,
    0x5c, 0x5c, 0x55, 0x55, 0x5c, 0x5c, 0xcc, 0x33, 0xdc, 0xdc, 0xdd, 0x77, 0xdc, 0xdc, 0xcc, 0x33,
    0x3c, 0x3c, 0x33, 0xcc, 0x3c, 0x3c, 0xcc, 0x33, 0xbc, 0xbc, 0xbb, 0xee, 0xbc, 0xbc, 0xcc, 0x33,
    0x7c, 0x7c, 0x77, 0xdd, 0x7c, 0x7c, 0xcc, 0x33, 0xfc, 0xfc, 0xff, 0xff, 0xfc, 0xfc, 0xcc, 0x33,
    0x02, 0x02, 0x00, 0x00, 0x02, 0x02, 0x22, 0x88, 0x82, 0x82, 0x88, 0x22, 0x82, 0x82, 0x22, 0x88,
    0x42, 0x42, 0x44, 0x11, 0x42, 0x42, 0x22, 0x88, 0xc2, 0xc2, 0xcc, 0x33, 0xc2, 0xc2, 0x22, 0x88,
    0x22, 0x22, 0x22, 0x88, 0x22, 0x22, 0x22, 0x88, 0xa2, 0xa2, 0xaa, 0xaa, 0xa2, 0xa2, 0x22, 0x88,
    0x62, 0x62, 0x66, 0x99, 0x62, 0x62, 0x22, 0x88, 0xe2, 0xe2, 0xee, 0xbb, 0xe2, 0xe2, 0x22, 0x88,
    0x12, 0x12, 0x11, 0x44, 0x12, 0x12, 0x22, 0x88, 0x92, 0x92, 0x99, 0x66, 0x92, 0x92, 0x22, 0x88,
    0x52, 0x52, 0x55, 0x55, 0x52, 0x52, 0x22, 0x88, 0xd2, 0xd2, 0xdd, 0x77, 0xd2, 0xd2, 0x22, 0x88,
    0x32, 0x32, 0x33, 0xcc, 0x32, 0x32, 0x22, 0x88, 0xb2, 0xb2, 0xbb, 0xee, 0xb2, 0xb2, 0x22, 0x88,
    0x72, 0x72, 0x77, 0xdd, 0x72, 0x72, 0x22, 0x88, 0xf2, 0xf2, 0xff, 0xff, 0xf2, 0xf2, 0x22, 0x88,
    0x0a, 0x0a, 0x00, 0x00, 0x0a, 0x0a, 0xaa, 0xaa, 0x8a, 0x8a, 0x88, 0x22, 0x8a, 0x8a, 0xaa, 0xaa,
    0x4a, 0x4a, 0x44, 0x11, 0x4a, 0x4a, 0xaa, 0xaa, 0xca, 0xca, 0xcc, 0x33, 0xca, 0xca, 0xaa, 0xaa,
    0x2a, 0x2a, 0x22, 0x88, 0x2a, 0x2a, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
    0x6a, 0x6a, 0x66, 0x99, 0x6a, 0x6a, 0xaa, 0xaa, 0xea, 0xea, 0xee, 0xbb, 0xea, 0xea, 0xaa, 0xaa,
    0x1a, 0x1a, 0x11, 0x44, 0x1a, 0x1a, 0xaa, 0xaa, 0x9a, 0x9a, 0x99, 0x66, 0x9a, 0x9a, 0xaa, 0xaa,
    0x5a, 0x5a, 0x55, 0x55, 0x5a, 0x5a, 0xaa, 0xaa, 0xda, 0xda, 0xdd, 0x77, 0xda, 0xda, 0xaa, 0xaa,
    0x3a, 0x3a, 0x33, 0xcc, 0x3a, 0x3a, 0xaa, 0xaa, 0xba, 0xba, 0xbb, 0xee, 0xba, 0xba, 0xaa, 0xaa,
    0x7a, 0x7a, 0x77, 0xdd, 0x7a, 0x7a, 0xaa, 0xaa, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xaa, 0xaa,
    0x06, 0x06, 0x00, 0x00, 0x06, 0x06, 0x66, 0x99, 0x86, 0x86, 0x88, 0x22, 0x86, 0x86, 0x66, 0x99,
    0x46, 0x46, 0x44, 0x11, 0x46, 0x46, 0x66, 0x99, 0xc6, 0xc6, 0xcc, 0x33, 0xc6, 0xc6, 0x66, 0x99,
    0x26, 0x26, 0x22, 0x88, 0x26, 0x26, 0x66, 0x99, 0xa6, 0xa6, 0xaa, 0xaa, 0xa6, 0xa6, 0x66, 0x99,
    0x66, 0x66, 0x66, 0x99, 0x66, 0x66, 0x66, 0x99, 0xe6, 0xe6, 0xee, 0xbb, 0xe6, 0xe6, 0x66, 0x99,
    0x16, 0x16, 0x11, 0x44, 0x16, 0x16, 0x66, 0x99, 0x96, 0x96, 0x99, 0x66, 0x96, 0x96, 0x66, 0x99,
    0x56, 0x56, 0x55, 0x55, 0x56, 0x56, 0x66, 0x99, 0xd6, 0xd6, 0xdd, 0x77, 0xd6, 0xd6, 0x66, 0x99,
    0x36, 0x36, 0x33, 0xcc, 0x36, 0x36, 0x66, 0x99, 0xb6, 0xb6, 0xbb, 0xee, 0xb6, 0xb6, 0x66, 0x99,
    0x76, 0x76, 0x77, 0xdd, 0x76, 0x76, 0x66, 0x99, 0xf6, 0xf6, 0xff, 0xff, 0xf6, 0xf6, 0x66, 0x99,
    0x0e, 0x0e, 0x00, 0x00, 0x0e, 0x0e, 0xee, 0xbb, 0x8e, 0x8e, 0x88, 0x22, 0x8e, 0x8e, 0xee, 0xbb,
    0x4e, 0x4e, 0x44, 0x11, 0x4e, 0x4e, 0xee, 0xbb, 0xce, 0xce, 0xcc, 0x33, 0xce, 0xce, 0xee, 0xbb,
    0x2e, 0x2e, 0x22, 0x88, 0x2e, 0x2e, 0xee, 0xbb, 0xae, 0xae, 0xaa, 0xaa, 0xae, 0xae, 0xee, 0xbb,
    0x6e, 0x6e, 0x66, 0x99, 0x6e, 0x6e, 0xee, 0xbb, 0xee, 0xee, 0xee, 0xbb, 0xee, 0xee, 0xee, 0xbb,
    0x1e, 0x1e, 0x11, 0x44, 0x1e, 0x1e, 0xee, 0xbb, 0x9e, 0x9e, 0x99, 0x66, 0x9e, 0x9e, 0xee, 0xbb,
    0x5e, 0x5e, 0x55, 0x55, 0x5e, 0x5e, 0xee, 0xbb, 0xde, 0xde, 0xdd, 0x77, 0xde, 0xde, 0xee, 0xbb,
    0x3e, 0x3e, 0x33, 0xcc, 0x3e, 0x3e, 0xee, 0xbb, 0xbe, 0xbe, 0xbb, 0xee, 0xbe, 0xbe, 0xee, 0xbb,
    0x7e, 0x7e, 0x77, 0xdd, 0x7e, 0x7e, 0xee, 0xbb, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xee, 0xbb,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x44, 0x80, 0x80, 0x88, 0x22, 0x80, 0x80, 0x11, 0x44,
    0x40, 0x40, 0x44, 0x11, 0x40, 0x40, 0x11, 0x44, 0xc0, 0xc0, 0xcc, 0x33, 0xc0, 0xc0, 0x11, 0x44,
    0x20, 0x20, 0x22, 0x88, 0x20, 0x20, 0x11, 0x44, 0xa0, 0xa0, 0xaa, 0xaa, 0xa0, 0xa0, 0x11, 0x44,
    0x60, 0x60, 0x66, 0x99, 0x60, 0x60, 0x11, 0x44, 0xe0, 0xe0, 0xee, 0xbb, 0xe0, 0xe0, 0x11, 0x44,
    0x10, 0x10, 0x11, 0x44, 0x10, 0x10, 0x11, 0x44, 0x90, 0x90, 0x99, 0x66, 0x90, 0x90, 0x11, 0x44,
    0x50, 0x50, 0x55, 0x55, 0x50, 0x50, 0x11, 0x44, 0xd0, 0xd0, 0xdd, 0x77, 0xd0, 0xd0, 0x11, 0x44,
    0x30, 0x30, 0x33, 0xcc, 0x30, 0x30, 0x11, 0x44, 0xb0, 0xb0, 0xbb, 0xee, 0xb0, 0xb0, 0x11, 0x44,
    0x70, 0x70, 0x77, 0xdd, 0x70, 0x70, 0x11, 0x44, 0xf0, 0xf0, 0xff, 0xff, 0xf0, 0xf0, 0x11, 0x44,
    0x08, 0x08, 0x00, 0x00, 0x08, 0x08, 0x99, 0x66, 0x88, 0x88, 0x88, 0x22, 0x88, 0x88, 0x99, 0x66,
    0x48, 0x48, 0x44, 0x11, 0x48, 0x48, 0x99, 0x66, 0xc8, 0xc8, 0xcc, 0x33, 0xc8, 0xc8, 0x99, 0x66,
    0x28, 0x28, 0x22, 0x88, 0x28, 0x28, 0x99, 0x66, 0xa8, 0xa8, 0xaa, 0xaa, 0xa8, 0xa8, 0x99, 0x66,
    0x68, 0x68, 0x66, 0x99, 0x68, 0x68, 0x99, 0x66, 0xe8, 0xe8, 0xee, 0xbb, 0xe8, 0xe8, 0x99, 0x66,
    0x18, 0x18, 0x11, 0x44, 0x18, 0x18, 0x99, 0x66, 0x98, 0x98, 0x99, 0x66, 0x98, 0x98, 0x99, 0x66,
    0x58, 0x58, 0x55, 0x55, 0x58, 0x58, 0x99, 0x66, 0xd8, 0xd8, 0xdd, 0x77, 0xd8, 0xd8, 0x99, 0x66,
    0x38, 0x38, 0x33, 0xcc, 0x38, 0x38, 0x99, 0x66, 0xb8, 0xb8, 0xbb, 0xee, 0xb8, 0xb8, 0x99, 0x66,
    0x78, 0x78, 0x77, 0xdd, 0x78, 0x78, 0x99, 0x66, 0xf8, 0xf8, 0xff, 0xff, 0xf8, 0xf8, 0x99, 0x66,
    0x04, 0x04, 0x00, 0x00, 0x04, 0x04, 0x55, 0x55, 0x84, 0x84, 0x88, 0x22, 0x84, 0x84, 0x55, 0x55,
    0x44, 0x44, 0x44, 0x11, 0x44, 0x44, 0x55, 0x55, 0xc4, 0xc4, 0xcc, 0x33, 0xc4, 0xc4, 0x55, 0x55,
    0x24, 0x24, 0x22, 0x88, 0x24, 0x24, 0x55, 0x55, 0xa4, 0xa4, 0xaa, 0xaa, 0xa4, 0xa4, 0x55, 0x55,
    0x64, 0x64, 0x66, 0x99, 0x64, 0x64, 0x55, 0x55, 0xe4, 0xe4, 0xee, 0xbb, 0xe4, 0xe4, 0x55, 0x55,
    0x14, 0x14, 0x11, 0x44, 0x14, 0x14, 0x55, 0x55, 0x94, 0x94, 0x99, 0x66, 0x94, 0x94, 0x55, 0x55,
    0x54, 0x54, 0x55, 0x55, 0x54, 0x54, 0x55, 0x55, 0xd4, 0xd4, 0xdd, 0x77, 0xd4, 0xd4, 0x55, 0x55,
    0x34, 0x34, 0x33, 0xcc, 0x34, 0x34, 0x55, 0x55, 0xb4, 0xb4, 0xbb, 0xee, 0xb4, 0xb4, 0x55, 0x55,
    0x74, 0x74, 0x77, 0xdd, 0x74, 0x74, 0x55, 0x55, 0xf4, 0xf4, 0xff, 0xff, 0xf4, 0xf4, 0x55, 0x55,
    0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x0c, 0xdd, 0x77, 0x8c, 0x8c, 0x88, 0x22, 0x8c, 0x8c, 0xdd, 0x77,
    0x4c, 0x4c, 0x44, 0x11, 0x4c, 0x4c, 0xdd, 0x77, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc, 0xdd, 0x77,
    0x2c, 0x2c, 0x22, 0x88, 0x2c, 0x2c, 0xdd, 0x77, 0xac, 0xac, 0xaa, 0xaa, 0xac, 0xac, 0xdd, 0x77,
    0x6c, 0x6c, 0x66, 0x99, 0x6c, 0x6c, 0xdd, 0x77, 0xec, 0xec, 0xee, 0xbb, 0xec, 0xec, 0xdd, 0x77,
    0x1c, 0x1c, 0x11, 0x44, 0x1c, 0x1c, 0xdd, 0x77, 0x9c, 0x9c, 0x99, 0x66, 0x9c, 0x9c, 0xdd, 0x77,
    0x5c, 0x5c, 0x55, 0x55, 0x5c, 0x5c, 0xdd, 0x77, 0xdc, 0xdc, 0xdd, 0x77, 0xdc, 0xdc, 0xdd, 0x77,
    0x3c, 0x3c, 0x33, 0xcc, 0x3c, 0x3c, 0xdd, 0x77, 0xbc, 0xbc, 0xbb, 0xee, 0xbc, 0xbc, 0xdd, 0x77,
    0x7c, 0x7c, 0x77, 0xdd, 0x7c, 0x7c, 0xdd, 0x77, 0xfc, 0xfc, 0xff, 0xff, 0xfc, 0xfc, 0xdd, 0x77,
    0x02, 0x02, 0x00, 0x00, 0x02, 0x02, 0x33, 0xcc, 0x82, 0x82, 0x88, 0x22, 0x82, 0x82, 0x33, 0xcc,
    0x42, 0x42, 0x44, 0x11, 0x42, 0x42, 0x33, 0xcc, 0xc2, 0xc2, 0xcc, 0x33, 0xc2, 0xc2, 0x33, 0xcc,
    0x22, 0x22, 0x22, 0x88, 0x22, 0x22, 0x33, 0xcc, 0xa2, 0xa2, 0xaa, 0xaa, 0xa2, 0xa2, 0x33, 0xcc,
    0x62, 0x62, 0x66, 0x99, 0x62, 0x62, 0x33, 0xcc, 0xe2, 0xe2, 0xee, 0xbb, 0xe2, 0xe2, 0x33, 0xcc,
    0x12, 0x12, 0x11, 0x44, 0x12, 0x12, 0x33, 0xcc, 0x92, 0x92, 0x99, 0x66, 0x92, 0x92, 0x33, 0xcc,
    0x52, 0x52, 0x55, 0x55, 0x52, 0x52, 0x33, 0xcc, 0xd2, 0xd2, 0xdd, 0x77, 0xd2, 0xd2, 0x33, 0xcc,
    0x32, 0x32, 0x33, 0xcc, 0x32, 0x32, 0x33, 0xcc, 0xb2, 0xb2, 0xbb, 0xee, 0xb2, 0xb2, 0x33, 0xcc,
    0x72, 0x72, 0x77, 0xdd, 0x72, 0x72, 0x33, 0xcc, 0xf2, 0xf2, 0xff, 0xff, 0xf2, 0xf2, 0x33, 0xcc,
    0x0a, 0x0a, 0x00, 0x00, 0x0a, 0x0a, 0xbb, 0xee, 0x8a, 0x8a, 0x88, 0x22, 0x8a, 0x8a, 0xbb, 0xee,
    0x4a, 0x4a, 0x44, 0x11, 0x4a, 0x4a, 0xbb, 0xee, 0xca, 0xca, 0xcc, 0x33, 0xca, 0xca, 0xbb, 0xee,
    0x2a, 0x2a, 0x22, 0x88, 0x2a, 0x2a, 0xbb, 0xee, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xbb, 0xee,
    0x6a, 0x6a, 0x66, 0x99, 0x6a, 0x6a, 0xbb, 0xee, 0xea, 0xea, 0xee, 0xbb, 0xea, 0xea, 0xbb, 0xee,
    0x1a, 0x1a, 0x11, 0x44, 0x1a, 0x1a, 0xbb, 0xee, 0x9a, 0x9a, 0x99, 0x66, 0x9a, 0x9a, 0xbb, 0xee,
    0x5a, 0x5a, 0x55, 0x55, 0x5a, 0x5a, 0xbb, 0xee, 0xda, 0xda, 0xdd, 0x77, 0xda, 0xda, 0xbb, 0xee,
    0x3a, 0x3a, 0x33, 0xcc, 0x3a, 0x3a, 0xbb, 0xee, 0xba, 0xba, 0xbb, 0xee, 0xba, 0xba, 0xbb, 0xee,
    0x7a, 0x7a, 0x77, 0xdd, 0x7a, 0x7a, 0xbb, 0xee, 0xfa, 0xfa, 0xff, 0xff, 0xfa, 0xfa, 0xbb, 0xee,
    0x06, 0x06, 0x00, 0x00, 0x06, 0x06, 0x77, 0xdd, 0x86, 0x86, 0x88, 0x22, 0x86, 0x86, 0x77, 0xdd,
    0x46, 0x46, 0x44, 0x11, 0x46, 0x46, 0x77, 0xdd, 0xc6, 0xc6, 0xcc, 0x33, 0xc6, 0xc6, 0x77, 0xdd,
    0x26, 0x26, 0x22, 0x88, 0x26, 0x26, 0x77, 0xdd, 0xa6, 0xa6, 0xaa, 0xaa, 0xa6, 0xa6, 0x77, 0xdd,
    0x66, 0x66, 0x66, 0x99, 0x66, 0x66, 0x77, 0xdd, 0xe6, 0xe6, 0xee, 0xbb, 0xe6, 0xe6, 0x77, 0xdd,
    0x16, 0x16, 0x11, 0x44, 0x16, 0x16, 0x77, 0xdd, 0x96, 0x96, 0x99, 0x66, 0x96, 0x96, 0x77, 0xdd,
    0x56, 0x56, 0x55, 0x55, 0x56, 0x56, 0x77, 0xdd, 0xd6, 0xd6, 0xdd, 0x77, 0xd6, 0xd6, 0x77, 0xdd,
    0x36, 0x36, 0x33, 0xcc, 0x36, 0x36, 0x77, 0xdd, 0xb6, 0xb6, 0xbb, 0xee, 0xb6, 0xb6, 0x77, 0xdd,
    0x76, 0x76, 0x77, 0xdd, 0x76, 0x76, 0x77, 0xdd, 0xf6, 0xf6, 0xff, 0xff, 0xf6, 0xf6, 0x77, 0xdd,
    0x0e, 0x0e, 0x00, 0x00, 0x0e, 0x0e, 0xff, 0xff, 0x8e, 0x8e, 0x88, 0x22, 0x8e, 0x8e, 0xff, 0xff,
    0x4e, 0x4e, 0x44, 0x11, 0x4e, 0x4e, 0xff, 0xff, 0xce, 0xce, 0xcc, 0x33, 0xce, 0xce, 0xff, 0xff,
    0x2e, 0x2e, 0x22, 0x88, 0x2e, 0x2e, 0xff, 0xff, 0xae, 0xae, 0xaa, 0xaa, 0xae, 0xae, 0xff, 0xff,
    0x6e, 0x6e, 0x66, 0x99, 0x6e, 0x6e, 0xff, 0xff, 0xee, 0xee, 0xee, 0xbb, 0xee, 0xee, 0xff, 0xff,
    0x1e, 0x1e, 0x11, 0x44, 0x1e, 0x1e, 0xff, 0xff, 0x9e, 0x9e, 0x99, 0x66, 0x9e, 0x9e, 0xff, 0xff,
    0x5e, 0x5e, 0x55, 0x55, 0x5e, 0x5e, 0xff, 0xff, 0xde, 0xde, 0xdd, 0x77, 0xde, 0xde, 0xff, 0xff,
    0x3e, 0x3e, 0x33, 0xcc, 0x3e, 0x3e, 0xff, 0xff, 0xbe, 0xbe, 0xbb, 0xee, 0xbe, 0xbe, 0xff, 0xff,
    0x7e, 0x7e, 0x77, 0xdd, 0x7e, 0x7e, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff, 0xfe, 0xfe, 0xff, 0xff,
];

impl Video {
    const WIDTH: usize = 560;
    const HEIGHT: usize = 384;

    pub fn new() -> Self {
        let mut frame = vec![0xff; Video::WIDTH * Video::HEIGHT * 4];

        for y in 0..Video::HEIGHT {
            for x in 0..Video::WIDTH {
                // B,G,R,A
                frame[x * 4 + y * Video::WIDTH * 4] = 0x00;
                frame[x * 4 + 1 + y * Video::WIDTH * 4] = 0x00;
                frame[x * 4 + 2 + y * Video::WIDTH * 4] = 0x00;
                frame[x * 4 + 3 + y * Video::WIDTH * 4] = 0xff;
            }
        }

        let lut_text = build_lut(true, false, true);
        let lut_text_2e = build_lut(true, true, true);
        let lut_hires = build_lut(false, true, true);

        let lut_text_pal = build_lut(true, false, false);
        let lut_text_2e_pal = build_lut(true, true, false);
        let lut_hires_pal = build_lut(false, true, false);

        let luma_bandwidth = NTSC_LUMA_BANDWIDTH;
        let chroma_bandwidth = NTSC_CHROMA_BANDWIDTH;
        let ntsc_decoder = decoder_matrix(NTSC_LUMA_BANDWIDTH, NTSC_CHROMA_BANDWIDTH);
        let cycle_field = CYCLES_PER_FIELD_60HZ;

        let chroma_hgr = default_chroma_hgr();
        let chroma_dhgr = default_chroma_dhgr();

        Video {
            frame,
            display_mode: DisplayMode::DEFAULT,
            video_main: vec![0u8; 0x10000],
            video_aux: vec![0u8; 0x10000],
            video_cache: vec![0x00; 40 * 192],
            video_reparse: vec![0x00; 192],
            video_dirty: vec![0x00; 24],
            lut_text,
            lut_text_2e,
            lut_hires,
            lut_text_pal,
            lut_text_2e_pal,
            lut_hires_pal,
            cycles: 0,
            cycle_field,
            blink: false,
            blink_time: (SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap_or(std::time::Duration::ZERO)
                .as_millis()) as u64,
            graphics_mode: false,
            mixed_mode: false,
            lores_mode: false,
            dhires_mode: false,
            _80storeon: false,
            vid80_mode: false,
            video_page2: false,
            altchar: false,
            video_latch: 0,
            prev_video_data: 0,
            apple2e: false,
            apple2e_enh: false,
            apple2c: false,
            video_50hz: false,
            mono_mode: false,
            rgb_mode: 0,
            ntsc_decoder,
            luma_bandwidth,
            chroma_bandwidth,
            chroma_hgr,
            chroma_dhgr,
            scanline: false,
            skip_update: false,
            color_burst: false,
            mac_lc_dlgr: false,
        }
    }

    pub fn get_cycles(&self) -> usize {
        self.cycles
    }

    pub fn reset(&mut self) {
        self._80storeon = false;
        self.vid80_mode = false;
        self.altchar = false;
    }

    pub fn update_video(&mut self) {
        let val = self.cycles;
        let (row, col) = (val / CYCLES_PER_ROW, val % CYCLES_PER_ROW);

        if val == 0 {
            let elapsed = (SystemTime::now()
                .duration_since(SystemTime::UNIX_EPOCH)
                .unwrap_or(std::time::Duration::ZERO)
                .as_millis()
                .saturating_sub(self.blink_time.into())) as u64;

            let blink_period = if !self.video_50hz {
                BLINK_PERIOD_60HZ
            } else {
                BLINK_PERIOD_50HZ
            };

            if elapsed > blink_period as u64 {
                if !self.vid80_mode {
                    self.blink = !self.blink;
                }
                self.blink_time = (SystemTime::now()
                    .duration_since(SystemTime::UNIX_EPOCH)
                    .unwrap_or(std::time::Duration::ZERO)
                    .as_millis()) as u64;
            }
        }

        // Video line takes 65 clock cycles
        // 25 clock cycle of horizontal blank
        // followed by 40 clock cycles displayed line
        let video_value = self.read_video_data(val, row);
        self.video_latch = self.prev_video_data;
        self.prev_video_data = video_value;

        if row >= 192 || col < CYCLES_PER_HBL {
            return;
        }

        let video_aux_latch = self.read_aux_video_data(val, row);
        let visible_col = col - CYCLES_PER_HBL;
        let video_mode = self.get_video_mode();
        let video_data = video_value as u32 | (video_aux_latch as u32) << 8 | video_mode;
        let video_index = visible_col + row * 40;
        let flash_status = self.get_flash_mode(video_data, video_mode);

        if self.video_cache[video_index] != video_data
            || self.video_reparse[row] != 0
            || flash_status
        {
            if self.video_cache[video_index] != video_data || flash_status {
                self.video_dirty[row / 8] = 1;
            }

            // Redraw the whole row in the next 2 cycle
            if self.video_reparse[row] != 0 {
                if visible_col == 39 {
                    if self.video_reparse[row] > 2 {
                        self.video_reparse[row] = 0;
                    } else {
                        self.video_dirty[row / 8] = 1;
                        self.video_reparse[row] += 1;
                    }
                }
            } else if self.video_cache[video_index] != video_data && self.video_reparse[row] == 0 {
                self.video_reparse[row] = 1;
            }

            self.video_cache[video_index] = video_data;

            if !self.graphics_mode || (self.mixed_mode && row >= 160) {
                if self.vid80_mode {
                    self.draw_char_a2_y(visible_col, row / 8, video_aux_latch, row % 8, 0);
                }
                self.draw_char_a2_y(visible_col, row / 8, video_value, row % 8, 7);
            } else if !self.lores_mode {
                if self.vid80_mode && self.dhires_mode {
                    self.draw_raw_dhires_a2_row_col(row, visible_col, video_value, video_aux_latch);
                } else {
                    self.draw_raw_hires_a2_row_col(row, visible_col, video_value);
                }
            } else {
                if self.vid80_mode {
                    self.draw_lores_a2_y(visible_col, row, video_aux_latch, 0, true);
                }
                self.draw_lores_a2_y(visible_col, row, video_value, 7, false);
            }
        }
    }

    pub fn update_shadow_memory(&mut self, aux_memory: bool, addr: u16, value: u8) {
        let mem = if aux_memory {
            &mut self.video_aux
        } else {
            &mut self.video_main
        };

        // Do not reparse video if value is not changed
        if mem[addr as usize] == value {
            return;
        }

        mem[addr as usize] = value;

        if (0x0400..=0x0bff).contains(&addr) {
            // 000000cd eabab000 -> 000abcde
            let row = ((addr & 0x18) | ((addr >> 7) & 0x06) | ((addr & 0x80) >> 7)) * 8;
            if row < 192 {
                let start = row as usize;
                for i in start..start + 8 {
                    self.video_reparse[i] = 1;
                }
            }
        } else if (0x2000..=0x5fff).contains(&addr) {
            // 000fghcd eabab000 -> abcdefgh
            let row = ((addr << 1) & 0xc0) | ((addr >> 4) & 0x38) | ((addr >> 10) & 0x07);
            if row < 192 {
                self.video_reparse[row as usize] = 1;
            }
        }
    }

    pub fn io_access(&mut self, addr: u16, _value: u8, write_flag: bool) -> u8 {
        let mut value = 0;
        let io_addr = (addr & 0xff) as u8;
        match io_addr {
            0x0c => {
                if self.apple2e && write_flag {
                    self.vid80_mode = false;
                    self.update_video();
                }
            }
            0x0d => {
                if self.apple2e && write_flag {
                    self.vid80_mode = true;
                    self.update_video();
                }
            }
            0x0e => {
                if self.apple2e && write_flag {
                    self.altchar = false;
                    for item in &mut self.video_dirty {
                        *item = 1;
                    }
                }
            }
            0x0f => {
                if (self.apple2e_enh || self.apple2c) && write_flag {
                    self.altchar = true;
                    for item in &mut self.video_dirty {
                        *item = 1;
                    }
                }
            }

            0x19 => {
                if self.apple2e {
                    let val = self.cycles;
                    let row = val / CYCLES_PER_ROW;
                    if row < 192 {
                        return 0x80;
                    } else {
                        return 0;
                    }
                }
            }

            0x1a => {
                if !self.graphics_mode {
                    return 0x80;
                }
            }
            0x1b => {
                if self.mixed_mode {
                    return 0x80;
                }
            }
            0x1c => {
                if self.video_page2 {
                    return 0x80;
                }
            }
            0x1d => {
                if !self.lores_mode {
                    return 0x80;
                }
            }
            0x1e => {
                if self.altchar {
                    return 0x80;
                }
            }
            0x1f => {
                if self.vid80_mode {
                    return 0x80;
                }
            }

            0x21 => {
                if write_flag {
                    self.mono_mode = _value & 0x80 > 0;
                } else if self.mono_mode {
                    value |= 0x80;
                }
            }

            0x29 => {
                if write_flag {
                    self.mono_mode = _value & 0x20 > 0;
                } else if self.mono_mode {
                    value |= 0x20;
                }
            }

            _ => {}
        }
        value
    }

    pub fn set_apple2e(&mut self, flag: bool) {
        self.apple2e = flag
    }

    pub fn is_apple2e(&self) -> bool {
        self.apple2e
    }

    pub fn set_apple2e_enh(&mut self, flag: bool) {
        self.apple2e_enh = flag
    }

    pub fn is_apple2e_enh(&self) -> bool {
        self.apple2e_enh
    }

    pub fn set_apple2c(&mut self, flag: bool) {
        self.apple2c = flag
    }

    pub fn is_apple2c(&self) -> bool {
        self.apple2c
    }

    pub fn clear_video_dirty(&mut self) {
        for item in &mut self.video_dirty {
            *item = 0;
        }
    }

    pub fn get_color_burst(&self) -> bool {
        self.color_burst
    }

    pub fn set_color_burst(&mut self, flag: bool) {
        self.color_burst = flag;
        self.invalidate_video_cache();
    }

    pub fn get_mac_lc_dlgr(&self) -> bool {
        self.mac_lc_dlgr
    }

    pub fn set_mac_lc_dlgr(&mut self, flag: bool) {
        self.mac_lc_dlgr = flag;
        self.invalidate_video_cache();
    }

    pub fn get_dirty_region(&self) -> Vec<(usize, usize)> {
        let mut vec: Vec<(usize, usize)> = Vec::new();
        let mut found = false;
        let mut start = 0;
        let mut end = 0;
        for (i, &item) in self.video_dirty.iter().enumerate() {
            if item > 0 {
                if !found {
                    start = i;
                    end = i;
                    found = true;
                } else {
                    end = i;
                }
            } else {
                if found {
                    vec.push((start, end));
                }
                found = false;
            }
        }
        if found {
            vec.push((start, end));
        }
        vec
    }

    pub fn invalidate_video_cache(&mut self) {
        for item in &mut self.video_cache {
            *item = u32::MAX;
        }
    }

    fn is_display_mode_mono(&self) -> bool {
        self.display_mode == DisplayMode::MONO_WHITE
            || self.display_mode == DisplayMode::MONO_GREEN
            || self.display_mode == DisplayMode::MONO_AMBER
    }

    fn get_mono_color(&self) -> Rgb {
        if self.display_mode == DisplayMode::MONO_GREEN {
            COLOR_GREEN
        } else if self.display_mode == DisplayMode::MONO_AMBER {
            COLOR_ORANGE
        } else {
            COLOR_WHITE
        }
    }

    fn get_video_mode(&self) -> u32 {
        let mut mode: u32 = 0;

        if !self.graphics_mode {
            mode |= 0x1;
        }
        if self.mixed_mode {
            mode |= 0x2;
        }
        if self.lores_mode {
            mode |= 0x4;
        }
        if self.video_page2 {
            mode |= 0x8;
        }
        if self.vid80_mode {
            mode |= 0x10;
        }
        if self.dhires_mode {
            mode |= 0x20;
        }
        if self.is_display_mode_mono()
            || self.mono_mode
            || (self.display_mode == DisplayMode::RGB && self.rgb_mode == 0x3)
        {
            mode |= 0x40;
        }
        mode << 16
    }

    fn get_flash_mode(&self, video_data: u32, video_mode: u32) -> bool {
        let mode = video_mode >> 16;

        // Flash mode is not available in 80 col
        if mode & 0x10 != 0 {
            return false;
        }

        // Flash only on text or mixed mode
        (video_data & 0xff) & 0xc0 == 0x40 && mode & 3 != 0
    }

    fn read_video_text_data(&self, cycle: usize) -> u8 {
        if self.apple2e {
            if !self.video_50hz {
                self.read_raw_text_memory(self.lut_text_2e[cycle])
            } else {
                self.read_raw_text_memory(self.lut_text_2e_pal[cycle])
            }
        } else if !self.video_50hz {
            self.read_raw_text_memory(self.lut_text[cycle])
        } else {
            self.read_raw_text_memory(self.lut_text_pal[cycle])
        }
    }

    fn read_video_data(&mut self, cycle: usize, r: usize) -> u8 {
        if self.graphics_mode && (!self.mixed_mode || r < 160) && !self.lores_mode {
            if !self.video_50hz {
                self.read_raw_hires_memory(self.lut_hires[cycle])
            } else {
                self.read_raw_hires_memory(self.lut_hires_pal[cycle])
            }
        } else {
            self.read_video_text_data(cycle)
        }
    }

    fn read_video_aux_text_data(&self, cycle: usize) -> u8 {
        if self.apple2e {
            if !self.video_50hz {
                self.read_raw_aux_text_memory(self.lut_text_2e[cycle])
            } else {
                self.read_raw_aux_text_memory(self.lut_text_2e_pal[cycle])
            }
        } else if !self.video_50hz {
            self.read_raw_aux_text_memory(self.lut_text[cycle])
        } else {
            self.read_raw_aux_text_memory(self.lut_text_pal[cycle])
        }
    }

    fn read_aux_video_data(&mut self, cycle: usize, r: usize) -> u8 {
        if self.graphics_mode && (!self.mixed_mode || r < 160) && !self.lores_mode {
            if !self.video_50hz {
                self.read_raw_aux_hires_memory(self.lut_hires[cycle])
            } else {
                self.read_raw_aux_hires_memory(self.lut_hires_pal[cycle])
            }
        } else {
            self.read_video_aux_text_data(cycle)
        }
    }

    fn read_text_memory(&mut self, col: usize, row: usize) -> u8 {
        let line = row / 8;

        // 000000cd eabab000 -> 000abcde
        let ab = line & 0x18;
        let cde = (line & 0x7) << 7;
        let addr = cde | ab | ab << 2;

        self.read_raw_text_memory(addr + col)
    }

    fn read_aux_text_memory(&mut self, col: usize, row: usize) -> u8 {
        let line = row / 8;

        // 000000cd eabab000 -> 000abcde
        let ab = line & 0x18;
        let cde = (line & 0x7) << 7;
        let addr = cde | ab | ab << 2;

        self.read_raw_aux_text_memory(addr + col)
    }

    fn read_raw_text_memory(&self, addr: usize) -> u8 {
        if self.video_page2 {
            if !self._80storeon {
                self.video_main[(addr as u16 + 0x800) as usize]
            } else {
                self.video_main[(addr as u16 + 0x400) as usize]
            }
        } else {
            self.video_main[(addr as u16 + 0x400) as usize]
        }
    }

    fn read_raw_aux_text_memory(&self, addr: usize) -> u8 {
        if self.video_page2 {
            if !self._80storeon {
                self.video_aux[(addr as u16 + 0x800) as usize]
            } else {
                self.video_aux[(addr as u16 + 0x400) as usize]
            }
        } else {
            self.video_aux[(addr as u16 + 0x400) as usize]
        }
    }

    fn hires_address(&mut self, row: usize) -> usize {
        /*
        // 000fghcd eabab000 -> abcdefgh
        let ab = row & 0xc0;
        let cde = (row & 0x38) << 4;
        let fgh = (row & 0x7) << 10;

        let addr = fgh | cde | ab >> 1 | ab >> 3;
        */

        // From applewin : https://github.com/AppleWin/AppleWin/wiki
        (row & 7) * 0x400 + ((row / 8) & 7) * 0x80 + (row / 64) * 0x28
    }

    fn read_hires_memory(&mut self, col: usize, row: usize) -> u8 {
        let addr = self.hires_address(row);
        self.read_raw_hires_memory(addr + col)
    }

    fn read_aux_hires_memory(&mut self, col: usize, row: usize) -> u8 {
        let addr = self.hires_address(row);
        self.read_raw_aux_hires_memory(addr + col)
    }

    fn read_raw_hires_memory(&self, addr: usize) -> u8 {
        if self.video_page2 {
            if !self._80storeon {
                self.video_main[(addr as u16 + 0x4000) as usize]
            } else {
                self.video_main[(addr as u16 + 0x2000) as usize]
            }
        } else {
            self.video_main[(addr as u16 + 0x2000) as usize]
        }
    }

    fn read_raw_aux_hires_memory(&self, addr: usize) -> u8 {
        if self.video_page2 {
            if !self._80storeon {
                self.video_aux[(addr as u16 + 0x4000) as usize]
            } else {
                self.video_aux[(addr as u16 + 0x2000) as usize]
            }
        } else {
            self.video_aux[(addr as u16 + 0x2000) as usize]
        }
    }

    pub fn read_latch(&self) -> u8 {
        self.video_latch
    }

    pub fn set_scanline(&mut self, state: bool) {
        self.scanline = state;
        self.invalidate_video_cache();
    }

    pub fn get_scanline(&self) -> bool {
        self.scanline
    }

    pub fn enable_graphics(&mut self, state: bool) {
        self.graphics_mode = state;
    }

    pub fn enable_lores(&mut self, state: bool) {
        self.lores_mode = state;
    }

    pub fn enable_dhires(&mut self, state: bool) {
        if !state && self.dhires_mode {
            // Set the video-7 mode

            // F2  F1  Video Mode
            // 0   0   140x192
            // 0   1   160x192
            // 1   0   Mix
            // 1   1   560x192
            let vid_80 = 1 - (self.vid80_mode as u8);
            self.rgb_mode = (self.rgb_mode << 1) & 3 | vid_80;
        }
        self.dhires_mode = state;
    }

    pub fn enable_mixed_mode(&mut self, state: bool) {
        self.mixed_mode = state;
    }

    pub fn enable_video_page2(&mut self, state: bool) {
        self.video_page2 = state;
    }

    pub fn is_graphics(&self) -> bool {
        self.graphics_mode
    }

    pub fn is_dhires_mode(&self) -> bool {
        self.dhires_mode
    }

    pub fn is_hires_mode(&self) -> bool {
        !self.lores_mode
    }

    pub fn is_video_page2(&self) -> bool {
        self.video_page2
    }

    pub fn is_vid80_mode(&self) -> bool {
        self.vid80_mode
    }

    pub fn is_vbl(&self) -> bool {
        let val = self.cycles;
        let row = val / CYCLES_PER_ROW;
        row >= 192
    }

    pub fn enable_video_80col(&mut self, state: bool) {
        self.vid80_mode = state;
    }

    pub fn toggle_video_freq(&mut self) {
        self.video_50hz = !self.video_50hz;
        if self.video_50hz {
            self.cycle_field = CYCLES_PER_FIELD_50HZ
        } else {
            self.cycle_field = CYCLES_PER_FIELD_60HZ
        }
        self.invalidate_video_cache();
    }

    pub fn get_mono_mode(&self) -> bool {
        self.mono_mode
    }

    pub fn get_display_mode(&self) -> DisplayMode {
        self.display_mode
    }

    pub fn set_display_mode(&mut self, mode: DisplayMode) {
        self.display_mode = mode;
        self.invalidate_video_cache();
    }

    pub fn set_mono_mode(&mut self, state: bool) {
        self.mono_mode = state;
        self.invalidate_video_cache();
    }

    pub fn set_video_50hz(&mut self, flag: bool) {
        self.video_50hz = flag;
        if self.video_50hz {
            self.cycle_field = CYCLES_PER_FIELD_50HZ
        } else {
            self.cycle_field = CYCLES_PER_FIELD_60HZ
        }
        self.invalidate_video_cache();
    }

    pub fn is_video_50hz(&self) -> bool {
        self.video_50hz
    }

    pub fn update_ntsc_matrix(&mut self, luma_bandwidth: f32, chroma_bandwidth: f32) {
        self.ntsc_decoder = decoder_matrix(luma_bandwidth, chroma_bandwidth);
        let new_chroma_hgr = generate_chroma(&self.ntsc_decoder, false);
        let new_chroma_dhgr = generate_chroma(&self.ntsc_decoder, true);
        self.chroma_hgr = new_chroma_hgr;
        self.chroma_dhgr = new_chroma_dhgr;
    }

    pub fn set_pixel(&mut self, x: usize, y: usize, rgb: Rgb) {
        let base = y * 4 * Video::WIDTH + x * 4;
        let [r, g, b] = rgb;
        self.frame[base] = r;
        self.frame[base + 1] = g;
        self.frame[base + 2] = b;
    }

    pub fn set_pixel_2(&mut self, x: usize, y: usize, rgb: Rgb) {
        let base = y * 4 * Video::WIDTH + x * 4;
        let offset = 4 * Video::WIDTH;
        let [r, g, b] = rgb;
        self.frame[base] = r;
        self.frame[base + 1] = g;
        self.frame[base + 2] = b;

        if !self.scanline {
            self.frame[base + offset] = r;
            self.frame[base + offset + 1] = g;
            self.frame[base + offset + 2] = b;
        } else {
            self.frame[base + offset] = self.frame[base] / 2;
            self.frame[base + offset + 1] = self.frame[base + 1] / 2;
            self.frame[base + offset + 2] = self.frame[base + 2] / 2;
        }
    }

    pub fn set_pixel_blend_alpha(&mut self, x: usize, y: usize, rgb: Rgb, alpha: u8) {
        let base = y * 4 * Video::WIDTH + x * 4;
        let [r, g, b] = rgb;
        let alpha_ratio: f32 = alpha as f32 / 255.0;
        self.frame[base] =
            (self.frame[base] as f32 * (1.0 - alpha_ratio)) as u8 + (r as f32 * alpha_ratio) as u8;
        self.frame[base + 1] = (self.frame[base + 1] as f32 * (1.0 - alpha_ratio)) as u8
            + (g as f32 * alpha_ratio) as u8;
        self.frame[base + 2] = (self.frame[base + 2] as f32 * (1.0 - alpha_ratio)) as u8
            + (b as f32 * alpha_ratio) as u8;
    }

    pub fn set_pixel_count(&mut self, x: usize, y: usize, rgb: Rgb, count: usize) {
        for i in 0..count {
            if x + i < Video::WIDTH {
                self.set_pixel_2(x + i, y, rgb);
            } else {
                break;
            }
        }
    }

    pub fn set_a2_pixel(&mut self, x: usize, y: usize, rgb: Rgb) {
        let base = 8 * (y * Video::WIDTH + x);
        let offset = 4 * Video::WIDTH;

        let [r, g, b] = rgb;

        self.frame[base] = r;
        self.frame[base + 1] = g;
        self.frame[base + 2] = b;
        self.frame[base + 4] = r;
        self.frame[base + 5] = g;
        self.frame[base + 6] = b;

        if !self.scanline {
            self.frame[base + offset] = r;
            self.frame[base + 1 + offset] = g;
            self.frame[base + 2 + offset] = b;
            self.frame[base + 4 + offset] = r;
            self.frame[base + 5 + offset] = g;
            self.frame[base + 6 + offset] = b;
        } else {
            self.frame[base + offset] = r / 2;
            self.frame[base + 1 + offset] = g / 2;
            self.frame[base + 2 + offset] = b / 2;
            self.frame[base + 4 + offset] = r / 2;
            self.frame[base + 5 + offset] = g / 2;
            self.frame[base + 6 + offset] = b / 2;
        }
    }

    pub fn draw_line(&mut self, x1: usize, y1: usize, x2: usize, y2: usize, rgb: Rgb) {
        let dx: i32 = (x2 as i32 - x1 as i32).abs();
        let sx: i32 = if x1 < x2 { 1 } else { -1 };
        let dy: i32 = -((y2 as i32 - y1 as i32).abs());
        let sy: i32 = if y1 < y2 { 1 } else { -1 };

        let mut err = dx + dy;

        let mut x: i32 = x1 as i32;
        let mut y: i32 = y1 as i32;
        loop {
            self.set_pixel(x as usize, y as usize, rgb);
            if x == x2 as i32 && y == y2 as i32 {
                break;
            }
            let e2 = 2 * err;
            if e2 >= dy {
                err += dy;
                x += sx;
            } else if e2 <= dx {
                err += dx;
                y += sy;
            }
        }
    }

    pub fn draw_line_a2(&mut self, x1: usize, y1: usize, x2: usize, y2: usize, rgb: Rgb) {
        let dx: i32 = (x2 as i32 - x1 as i32).abs();
        let sx: i32 = if x1 < x2 { 1 } else { -1 };
        let dy: i32 = -((y2 as i32 - y1 as i32).abs());
        let sy: i32 = if y1 < y2 { 1 } else { -1 };

        let mut err = dx + dy;

        let mut x: i32 = x1 as i32;
        let mut y: i32 = y1 as i32;
        loop {
            self.set_a2_pixel(x as usize, y as usize, rgb);
            if x == x2 as i32 && y == y2 as i32 {
                break;
            }
            let e2 = 2 * err;
            if e2 >= dy {
                err += dy;
                x += sx;
            } else if e2 <= dx {
                err += dx;
                y += sy;
            }
        }
    }

    pub fn draw_char_raw_a2(
        &mut self,
        x1: usize,
        y1: usize,
        ch: u8,
        alpha: u8,
        altflag: bool,
        color: Rgb,
    ) {
        debug_assert!(x1 < 80);
        debug_assert!(y1 < 48);

        let val = if !altflag {
            if (0x20..0x80).contains(&ch) {
                ch + 0x80
            } else {
                ch
            }
        } else {
            ch
        };

        let back_color;
        let fore_color;

        if altflag {
            back_color = color;
            fore_color = COLOR_BLACK;
        } else {
            back_color = COLOR_BLACK;
            fore_color = color;
        }

        let x1offset = x1 * 7;
        let y1offset = y1 * 8;
        for yindex in 0..8 {
            let mut shift = 0x80;
            let bitmap = CHAR_APPLE2E_ROM[val as usize * 8 + yindex];

            for xindex in x1offset..x1offset + 7 {
                let color = if bitmap & shift == 0 {
                    if altflag {
                        fore_color
                    } else {
                        back_color
                    }
                } else if altflag {
                    back_color
                } else {
                    fore_color
                };
                self.set_pixel_blend_alpha(xindex, y1offset + yindex, color, alpha);
                shift >>= 1;
            }
        }
    }

    pub fn draw_box_raw_a2(&mut self, x: usize, y: usize, w: usize, h: usize, alpha: u8) {
        // Draw top edge
        for i in 0..w - 1 {
            self.draw_char_raw_a2(x + i, y, b'_', alpha, false, COLOR_WHITE);
        }

        // Draw left edge
        for i in 1..h - 1 {
            self.draw_char_raw_a2(x, y + i, b'_', alpha, true, COLOR_WHITE);
        }

        // Draw right edge
        for i in 1..h {
            self.draw_char_raw_a2(x + w - 1, y + i, b'_', alpha, true, COLOR_WHITE);
        }

        // Draw left corner
        self.draw_char_raw_a2(x, y + h - 1, b'T', alpha, true, COLOR_WHITE);

        // Draw bottom edge
        for i in 1..w - 1 {
            self.draw_char_raw_a2(x + i, y + h - 1, b'_', alpha, false, COLOR_WHITE);
        }
    }

    pub fn draw_string_raw_a2(
        &mut self,
        x1: usize,
        y1: usize,
        str: &str,
        altflag: bool,
        color: Rgb,
    ) {
        self.draw_string_raw_a2_alpha(x1, y1, str, 255, altflag, color);
    }

    pub fn draw_string_raw_a2_alpha(
        &mut self,
        x1: usize,
        y1: usize,
        str: &str,
        alpha: u8,
        altflag: bool,
        color: Rgb,
    ) {
        let mut x = x1;
        for ch in str.chars() {
            if x < 80 {
                self.draw_char_raw_a2(x, y1, ch as u8, alpha, altflag, color);
            }
            x += 1;
        }
    }

    pub fn draw_char_a2(&mut self, x1: usize, y1: usize, ch: u8) {
        debug_assert!(x1 < 40);
        debug_assert!(y1 < 24);

        if self.mixed_mode && self.graphics_mode && y1 < 20 {
            return;
        }

        for yindex in 0..8 {
            self.draw_char_a2_y(x1, y1, ch, yindex, 0);
        }
    }

    fn get_font_bitmap(&self, val: u8, offset: usize) -> u8 {
        if self.apple2e {
            CHAR_APPLE2E_ROM[val as usize * 8 + offset]
        } else {
            CHAR_APPLE2_ROM[val as usize * 8 + offset]
        }
    }

    fn draw_char_a2_y(&mut self, x1: usize, y1: usize, ch: u8, yindex: usize, offset: usize) {
        let val = if !self.altchar {
            if (0x40..0x80).contains(&ch) {
                ch - 0x40
            } else {
                ch
            }
        } else {
            ch
        };

        let bitmap = self.get_font_bitmap(val, yindex);
        let flash = ch & 0xc0 == 0x40 && self.blink && !self.vid80_mode && !self.altchar;
        let normal = ch & 0x80 > 0;
        let mut back_color;
        let mut fore_color;

        let mono_color = self.get_mono_color();

        if normal {
            if !flash {
                back_color = COLOR_BLACK;
                fore_color = mono_color;
            } else {
                back_color = mono_color;
                fore_color = COLOR_BLACK;
            }
        } else if !flash {
            if self.apple2e {
                back_color = COLOR_BLACK;
                fore_color = mono_color;
            } else {
                back_color = mono_color;
                fore_color = COLOR_BLACK;
            }
        } else if self.apple2e {
            back_color = mono_color;
            fore_color = COLOR_BLACK;
        } else {
            back_color = COLOR_BLACK;
            fore_color = mono_color;
        }

        if self.display_mode == DisplayMode::RGB && self.dhires_mode && !self.vid80_mode {
            let aux_value = self.read_aux_text_memory(x1, y1);
            back_color = LORES_COLORS[(aux_value & 0xf) as usize];
            fore_color = LORES_COLORS[((aux_value >> 4) & 0xf) as usize];
        }

        let mut shift = 0x80;
        if !self.apple2e {
            shift >>= 1;
        }

        if !self.vid80_mode {
            let x1offset = x1 * 7;
            let y1offset = y1 * 8 + yindex;
            if self.graphics_mode
                && self.color_burst
                && !self.video_50hz
                && !self.is_display_mode_mono()
                && !self.mono_mode
            {
                let mut data = bitmap.reverse_bits() & 0x7f;
                if !self.apple2e {
                    data >>= 1;
                }
                if flash {
                    data ^= 0x7f;
                }
                self.draw_raw_hires_a2_row_col(y1offset, x1, data);
            } else {
                for xindex in x1offset..x1offset + 7 {
                    let color = if bitmap & shift == 0 {
                        back_color
                    } else {
                        fore_color
                    };
                    self.set_a2_pixel(xindex, y1offset, color);
                    shift >>= 1;
                }
            }
        } else {
            let x1offset = x1 * 14 + offset;
            let y1offset = y1 * 16 + yindex * 2;
            if self.graphics_mode
                && self.color_burst
                && !self.video_50hz
                && !self.is_display_mode_mono()
                && !self.mono_mode
                && !self.dhires_mode
            {
                let data = bitmap.reverse_bits();
                let alt_ch = self.read_aux_text_memory(x1, y1 * 8 + yindex);
                let alt_val = if !self.altchar {
                    if (0x40..0x80).contains(&alt_ch) {
                        alt_ch - 0x40
                    } else {
                        alt_ch
                    }
                } else {
                    alt_ch
                };
                let alt_data = self.get_font_bitmap(alt_val, yindex).reverse_bits();
                self.draw_raw_dhires_a2_row_col(y1 * 8 + yindex, x1, data, alt_data);
            } else {
                for xindex in x1offset..x1offset + 7 {
                    let color = if bitmap & shift == 0 {
                        back_color
                    } else {
                        fore_color
                    };
                    self.set_pixel(xindex, y1offset, color);
                    if !self.scanline {
                        self.set_pixel(xindex, y1offset + 1, color);
                    } else {
                        self.set_pixel(
                            xindex,
                            y1offset + 1,
                            [color[0] / 2, color[1] / 2, color[2] / 2],
                        );
                    }

                    shift >>= 1;
                }
            }
        }
    }

    pub fn draw_lores_a2(&mut self, x1: usize, y1: usize, ch: u8) {
        debug_assert!(x1 < 40);
        debug_assert!(y1 < 24);

        let low_pixel_color = LORES_COLORS[(ch & 0xf) as usize];
        let high_pixel_color = LORES_COLORS[(ch >> 4 & 0xf) as usize];

        if self.mixed_mode && y1 > 19 {
            self.draw_char_a2(x1, y1, ch);
            return;
        }

        for yindex in 0..4 {
            for xindex in 0..7 {
                self.set_a2_pixel(x1 * 7 + xindex, y1 * 8 + yindex, low_pixel_color);
            }
        }

        for yindex in 4..8 {
            for xindex in 0..7 {
                self.set_a2_pixel(x1 * 7 + xindex, y1 * 8 + yindex, high_pixel_color);
            }
        }
    }

    pub fn draw_lores_a2_y(&mut self, x1: usize, y1: usize, ch: u8, offset: usize, aux: bool) {
        debug_assert!(x1 < 40);
        debug_assert!(y1 < 192);

        let yindex = y1 % 8;
        let color = if !aux {
            if yindex < 4 {
                LORES_COLORS[(ch & 0xf) as usize]
            } else {
                LORES_COLORS[(ch >> 4 & 0xf) as usize]
            }
        } else if yindex < 4 {
            if !self.mac_lc_dlgr {
                DHIRES_COLORS[(ch & 0xf) as usize]
            } else {
                LORES_COLORS[(ch & 0xf) as usize]
            }
        } else if !self.mac_lc_dlgr {
            DHIRES_COLORS[(ch >> 4 & 0xf) as usize]
        } else {
            LORES_COLORS[(ch >> 4 & 0xf) as usize]
        };

        if self.vid80_mode && self.dhires_mode {
            if !self.mono_mode && !(self.is_display_mode_mono()) {
                if self.display_mode == DisplayMode::NTSC
                    || self.display_mode == DisplayMode::MONO_NTSC
                {
                    self.draw_dlores_ntsc_a2_y(x1, y1, ch, offset, aux);
                } else {
                    for xindex in 0..7 {
                        self.set_pixel_count(x1 * 14 + xindex + offset, y1 * 2, color, 1);
                    }
                }
            } else {
                let color = if yindex < 4 {
                    ch & 0xf
                } else {
                    (ch >> 4) & 0xf
                };
                let mut mask = 0x1;
                if x1 & 1 != 0 {
                    mask <<= 2;
                }

                let mono_color = self.get_mono_color();

                for xindex in 0..7 {
                    if color & mask != 0 {
                        self.set_pixel_count(x1 * 14 + xindex + offset, y1 * 2, mono_color, 1);
                    } else {
                        self.set_pixel_count(x1 * 14 + xindex + offset, y1 * 2, COLOR_BLACK, 1);
                    }
                    mask <<= 1;
                    if mask > 0xf {
                        mask = 0x1;
                    }
                }
            }
        } else if !self.mono_mode && !(self.is_display_mode_mono()) {
            if self.display_mode == DisplayMode::NTSC || self.display_mode == DisplayMode::MONO_NTSC
            {
                self.draw_lores_ntsc_a2_y(x1, y1, ch);
            } else {
                for xindex in 0..7 {
                    self.set_a2_pixel(x1 * 7 + xindex, y1, color);
                }
            }
        } else {
            let color = if yindex < 4 {
                ch & 0xf
            } else {
                (ch >> 4) & 0xf
            };
            let mut mask = 0x1;
            if x1 & 1 != 0 {
                mask <<= 2;
            }

            let mono_color = self.get_mono_color();

            for xindex in 0..14 {
                if color & mask != 0 {
                    self.set_pixel_count(x1 * 14 + xindex, y1 * 2, mono_color, 1);
                } else {
                    self.set_pixel_count(x1 * 14 + xindex, y1 * 2, COLOR_BLACK, 1);
                }
                mask <<= 1;
                if mask > 0xf {
                    mask = 0x1;
                }
            }
        }
    }

    pub fn draw_lores_ntsc_a2_y(&mut self, x1: usize, y1: usize, ch: u8) {
        let mut offset = 0;
        let mut mask = 0x1;
        let mut luma = [0u8; 14 + 2 * NTSC_PIXEL_NEIGHBOR + 1];
        let yindex = y1 % 8;

        // Prepare luma for col - 1
        let prev_value = if x1 > 0 {
            let prev_ch = self.read_text_memory(x1 - 1, y1);
            if yindex < 4 {
                prev_ch & 0xf
            } else {
                (prev_ch >> 4) & 0xf
            }
        } else {
            0
        };
        if x1 > 0 && (x1 - 1) & 1 != 0 {
            mask <<= 2;
        }

        let mut count = 14 - NTSC_PIXEL_NEIGHBOR;
        while offset != NTSC_PIXEL_NEIGHBOR {
            if count == 0 {
                if prev_value & mask != 0 {
                    luma[offset] = 1;
                } else {
                    luma[offset] = 0;
                }
                offset += 1;
            } else {
                count -= 1;
            }
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        // Prepare luma for col
        let value = if yindex < 4 {
            ch & 0xf
        } else {
            (ch >> 4) & 0xf
        };
        mask = 0x1;
        if x1 & 1 != 0 {
            mask <<= 2;
        }
        for _ in 0..14 {
            if value & mask != 0 {
                luma[offset] = 1;
            } else {
                luma[offset] = 0;
            }
            offset += 1;
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        // Prepare luma for col + 1
        mask = 0x1;
        let next_value = if x1 < 39 {
            let next_ch = self.read_text_memory(x1 + 1, y1);
            if yindex < 4 {
                next_ch & 0xf
            } else {
                (next_ch >> 4) & 0xf
            }
        } else {
            0
        };
        if (x1 + 1) & 1 != 0 {
            mask <<= 2;
        }
        count = 0;
        while count != NTSC_PIXEL_NEIGHBOR {
            if next_value & mask != 0 {
                luma[offset] = 1;
            } else {
                luma[offset] = 0;
            }
            offset += 1;
            count += 1;
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        let x = x1 * 14;
        for i in 0..14 {
            let pos = (x + i) % 4;
            let luma_u32 = luma_to_u32(&luma, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR);
            let mut color = self.chroma_hgr[pos][luma_u32 as usize];

            if self.display_mode == DisplayMode::MONO_NTSC {
                let gray =
                    (((color[0] as u16) * 30 + (color[1] as u16) * 59 + (color[2] as u16) * 11)
                        / 100) as u8;
                color = [gray, gray, gray];
            }

            //let color = chroma_ntsc_color(&luma, x + i, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR, false, &self.ntsc_decoder);
            self.set_pixel_count(x + i, y1 * 2, color, 1);
        }
    }

    pub fn draw_dlores_ntsc_a2_y(
        &mut self,
        x1: usize,
        y1: usize,
        ch: u8,
        offset: usize,
        aux: bool,
    ) {
        let mut ptr = 0;
        let mut mask = 0x1;
        let mut luma = [0u8; 7 + 2 * NTSC_PIXEL_NEIGHBOR + 1];
        let yindex = y1 % 8;

        // Prepare luma for col - 1
        let prev_value = if !aux {
            if x1 & 1 != 0 {
                mask <<= 2
            }
            let prev_ch = self.read_aux_text_memory(x1, y1);
            if yindex < 4 {
                prev_ch & 0xf
            } else {
                (prev_ch >> 4) & 0xf
            }
        } else if x1 > 0 {
            if (x1 - 1) & 1 != 0 {
                mask <<= 2;
            }
            let prev_ch = self.read_text_memory(x1 - 1, y1);
            if yindex < 4 {
                prev_ch & 0xf
            } else {
                (prev_ch >> 4) & 0xf
            }
        } else {
            0
        };

        let mut count = 7 - NTSC_PIXEL_NEIGHBOR;
        while ptr != NTSC_PIXEL_NEIGHBOR {
            if count == 0 {
                if prev_value & mask != 0 {
                    luma[ptr] = 1;
                } else {
                    luma[ptr] = 0;
                }
                ptr += 1;
            } else {
                count -= 1;
            }
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        // Prepare luma for col
        let value = if yindex < 4 {
            ch & 0xf
        } else {
            (ch >> 4) & 0xf
        };
        mask = 0x1;
        if x1 & 1 != 0 {
            mask <<= 2;
        }
        for _ in 0..7 {
            if value & mask != 0 {
                luma[ptr] = 1;
            } else {
                luma[ptr] = 0;
            }
            ptr += 1;
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        // Prepare luma for col + 1
        mask = 0x1;
        let next_value = if aux {
            if x1 & 1 != 0 {
                mask <<= 2;
            }
            let next_ch = self.read_text_memory(x1, y1);
            if yindex < 4 {
                next_ch & 0xf
            } else {
                (next_ch >> 4) & 0xf
            }
        } else if x1 < 39 {
            if (x1 + 1) & 1 != 0 {
                mask <<= 2;
            }
            let next_ch = self.read_aux_text_memory(x1 + 1, y1);
            if yindex < 4 {
                next_ch & 0xf
            } else {
                (next_ch >> 4) & 0xf
            }
        } else {
            0
        };

        count = 0;
        while count != NTSC_PIXEL_NEIGHBOR {
            if next_value & mask != 0 {
                luma[ptr] = 1;
            } else {
                luma[ptr] = 0;
            }
            ptr += 1;
            count += 1;
            mask <<= 1;
            if mask > 0xf {
                mask = 0x1;
            }
        }

        let x = x1 * 14;

        for i in 0..7 {
            let pos = (x + offset + i) % 4;
            let luma_u32 = luma_to_u32(&luma, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR);
            let mut color = if self.mac_lc_dlgr && aux {
                self.chroma_hgr[pos][luma_u32 as usize]
            } else {
                self.chroma_dhgr[pos][luma_u32 as usize]
            };

            if self.display_mode == DisplayMode::MONO_NTSC {
                let gray =
                    (((color[0] as u16) * 30 + (color[1] as u16) * 59 + (color[2] as u16) * 11)
                        / 100) as u8;
                color = [gray, gray, gray];
            }
            //let color = chroma_ntsc_color(&luma, x + offset + i, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR, true, &self.ntsc_decoder);
            self.set_pixel_count(x + offset + i, y1 * 2, color, 1);
        }
    }

    pub fn draw_string_a2(&mut self, x1: usize, y1: usize, s: &str) {
        debug_assert!(x1 + s.len() < 40);
        debug_assert!(y1 < 24);
        let mut x = x1;
        for ch in s.chars() {
            self.draw_char_a2(x, y1, ch as u8);
            x += 1;
        }
    }

    fn draw_raw_hires_a2_row_col(&mut self, row: usize, col: usize, value: u8) {
        if self.is_display_mode_mono() || self.mono_mode {
            self.draw_raw_hires_mono_a2_row_col(row, col, value);
            return;
        }

        if self.display_mode == DisplayMode::NTSC || self.display_mode == DisplayMode::MONO_NTSC {
            self.draw_raw_hires_ntsc_a2_row_col(row, col, value);
            return;
        }

        // Only works for Rgb mode
        if self.display_mode == DisplayMode::RGB && !self.vid80_mode && self.dhires_mode {
            self._draw_raw_fb_hires_a2_row_col(row, col, value);
            return;
        }

        if row < 192 && col < 40 {
            let x = col * 14;
            let odd = col % 2 > 0;
            let dhires_mode =
                self.display_mode != DisplayMode::RGB && self.dhires_mode && !self.vid80_mode;
            let mixed_mode = self.mixed_mode && row >= 160;
            let mut color_index = 0;

            if col > 0 {
                let val = if mixed_mode {
                    if value & 0x1 > 0 {
                        0x7f
                    } else {
                        0
                    }
                } else {
                    self.read_hires_memory(col - 1, row)
                };
                let hbs = (val & 0x80 > 0) as u8;
                let index = if odd { 2 + hbs } else { hbs };
                if val & 0x20 > 0 {
                    color_index |= 1 << index;
                    color_index |= 1 << ((index + 1) % 4);
                } else {
                    color_index &= 1 << (index ^ 0xf);
                    color_index &= (1 << ((index + 1) % 4)) ^ 0xf;
                }

                if val & 0x40 > 0 {
                    color_index |= 1 << ((index + 2) % 4);
                    color_index |= 1 << ((index + 3) % 4);
                } else {
                    color_index &= (1 << ((index + 2) % 4)) ^ 0xf;
                    color_index &= (1 << ((index + 3) % 4)) ^ 0xf;
                }
            }

            let mut mask = 0x1;
            let mut offset = x;
            let hbs = (value & 0x80 > 0) as usize;
            let mut prev_color = if dhires_mode {
                DHIRES_COLORS[color_index as usize]
            } else {
                LORES_COLORS[color_index as usize]
            };

            while mask != 0x80 {
                let index = (offset + hbs) % 4;
                if value & mask > 0 {
                    color_index |= 1 << index;
                    color_index |= 1 << ((index + 1) % 4);
                } else {
                    color_index &= 1 << index ^ 0xf;
                    color_index &= 1 << ((index + 1) % 4) ^ 0xf;
                }

                let color = if dhires_mode {
                    DHIRES_COLORS[color_index as usize]
                } else {
                    LORES_COLORS[color_index as usize]
                };

                if prev_color == COLOR_BLACK && color != COLOR_BLACK {
                    self.set_pixel_count(offset + hbs, row * 2, prev_color, 1);
                    self.set_pixel_count(offset + hbs + 1, row * 2, color, 1);
                } else if prev_color != COLOR_BLACK && color == COLOR_BLACK {
                    self.set_pixel_count(offset + hbs, row * 2, color, 2);
                } else if prev_color == COLOR_WHITE && color != COLOR_WHITE {
                    self.set_pixel_count(offset + hbs, row * 2, prev_color, 1);
                    self.set_pixel_count(offset + hbs + 1, row * 2, color, 1);
                } else {
                    self.set_pixel_count(offset + hbs, row * 2, color, 2);
                }

                if offset + hbs > 0 {
                    self.set_pixel_count(offset + hbs - 1, row * 2, prev_color, 1);
                }

                prev_color = color;

                mask <<= 1;
                offset += 2;
            }
        }
    }

    fn draw_raw_hires_mono_a2_row_col(&mut self, row: usize, col: usize, value: u8) {
        if row < 192 && col < 40 {
            let x = col * 14;
            let hbs = (value & 0x80 > 0) as usize;
            let mut offset = 0;
            let mut mask = 0x1;
            let mono_color = self.get_mono_color();

            if hbs > 0 {
                let bit = if col > 0 {
                    let prev_value = self.read_hires_memory(col - 1, row);
                    (prev_value & 0x40 != 0) as usize
                } else {
                    0
                };

                if bit != 0 {
                    self.set_pixel_count(x, 2 * row, mono_color, 1);
                } else {
                    self.set_pixel_count(x, 2 * row, COLOR_BLACK, 1);
                }
            }

            while mask != 0x80 {
                if value & mask > 0 {
                    self.set_pixel_count(hbs + x + 2 * offset, 2 * row, mono_color, 2);
                } else {
                    self.set_pixel_count(hbs + x + 2 * offset, 2 * row, COLOR_BLACK, 2);
                }
                mask <<= 1;
                offset += 1;
            }
        }
    }

    fn draw_raw_hires_ntsc_a2_row_col(&mut self, row: usize, col: usize, value: u8) {
        if row < 192 && col < 40 {
            let mixed_mode = self.mixed_mode && row >= 160;
            let an3 = self.display_mode != DisplayMode::RGB && self.dhires_mode && !self.vid80_mode;
            let mut luma = [0u8; 14 + 2 * NTSC_PIXEL_NEIGHBOR + 1];
            // Populate col-1 luma
            let prev_value = if col > 0 {
                if !an3 && mixed_mode {
                    if value & 0x1 > 0 {
                        0x7f
                    } else {
                        0
                    }
                } else {
                    self.read_hires_memory(col - 1, row)
                }
            } else {
                0
            };
            let mut offset = 0;
            let mut hbs = (prev_value & 0x80 > 0) as usize;
            let mut mask = 1 << (7 - (NTSC_PIXEL_NEIGHBOR / 2));
            if hbs > 0 {
                if prev_value & (mask >> 1) > 0 {
                    luma[2 * offset] = 1
                } else {
                    luma[2 * offset] = 0
                }
            }
            while mask != 0x80 {
                if prev_value & mask > 0 {
                    luma[hbs + 2 * offset] = 1;
                    luma[hbs + 2 * offset + 1] = 1;
                } else {
                    luma[hbs + 2 * offset] = 0;
                    luma[hbs + 2 * offset + 1] = 0;
                }
                mask <<= 1;
                offset += 1;
            }

            // Populate col luma
            mask = 0x1;
            hbs = (value & 0x80 > 0) as usize;
            if hbs > 0 {
                if prev_value & 0x40 > 0 {
                    luma[2 * offset] = 1
                } else {
                    luma[2 * offset] = 0
                }
            }
            while mask != 0x80 {
                if value & mask > 0 {
                    luma[hbs + 2 * offset] = 1;
                    luma[hbs + 2 * offset + 1] = 1;
                } else {
                    luma[hbs + 2 * offset] = 0;
                    luma[hbs + 2 * offset + 1] = 0;
                }
                mask <<= 1;
                offset += 1;
            }

            // Populate col+1 luma
            let next_value = if col < 39 {
                if !an3 && mixed_mode {
                    if value & 0x1 > 0 {
                        0x7f
                    } else {
                        0
                    }
                } else {
                    self.read_hires_memory(col + 1, row)
                }
            } else {
                0
            };
            mask = 0x1;
            hbs = (next_value & 0x80 > 0) as usize;
            if hbs > 0 {
                if value & 0x40 > 0 {
                    luma[2 * offset] = 1
                } else {
                    luma[2 * offset] = 0
                }
            }
            while mask != (1 << (NTSC_PIXEL_NEIGHBOR / 2)) {
                if next_value & mask > 0 {
                    luma[hbs + 2 * offset] = 1;
                    luma[hbs + 2 * offset + 1] = 1;
                } else {
                    luma[hbs + 2 * offset] = 0;
                    luma[hbs + 2 * offset + 1] = 0;
                }
                mask <<= 1;
                offset += 1;
            }

            let x = col * 14;
            for i in 0..14 {
                let pos = (x + i) % 4;
                let luma_u32 = luma_to_u32(&luma, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR);
                let mut color = if an3 {
                    self.chroma_dhgr[pos][luma_u32 as usize]
                } else {
                    self.chroma_hgr[pos][luma_u32 as usize]
                };

                if self.display_mode == DisplayMode::MONO_NTSC {
                    let gray =
                        (((color[0] as u16) * 30 + (color[1] as u16) * 59 + (color[2] as u16) * 11)
                            / 100) as u8;
                    color = [gray, gray, gray];
                }
                //let color = chroma_ntsc_color(&luma, x + i, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR, an3, &self.ntsc_decoder);
                self.set_pixel_count(x + i, 2 * row, color, 1);
            }
        }
    }

    // ----- Video-7 SL7 extra modes ----- (from the videocard manual)
    //  AN3 TEXT HIRES 80COL
    //   0    1    ?     0    F/B Text
    //   0    1    ?     1    80 col Text
    //   0    0    0     0    LoRes (mixed with F/B Text)
    //   0    0    0     1    DLoRes (mixed with 80 col. Text)
    //   0    0    1     0    F/B HiRes (mixed with F/B Text)
    fn _draw_raw_fb_hires_a2_row_col(&mut self, row: usize, col: usize, value: u8) {
        if row < 192 && col < 40 {
            let x = col * 14;
            let mut offset = 0;
            let mut mask = 0x1;

            let aux_value = self.read_aux_hires_memory(col, row);
            let bg_color = LORES_COLORS[(aux_value & 0xf) as usize];
            let fg_color = LORES_COLORS[((aux_value >> 4) & 0xf) as usize];

            while mask != 0x80 {
                if value & mask > 0 {
                    self.set_pixel_count(x + 2 * offset, 2 * row, fg_color, 2);
                } else {
                    self.set_pixel_count(x + 2 * offset, 2 * row, bg_color, 2);
                }
                mask <<= 1;
                offset += 1;
            }
        }
    }

    fn draw_raw_dhires_a2_row_col(&mut self, row: usize, col: usize, value: u8, aux_value: u8) {
        if self.display_mode == DisplayMode::RGB && self.rgb_mode == 0x3
            || self.mono_mode
            || self.is_display_mode_mono()
        {
            self.draw_raw_dhires_mono_a2_row_col(row, col, value, aux_value);
            return;
        }

        if self.display_mode == DisplayMode::RGB && self.rgb_mode == 0x1 {
            self.draw_raw_dhires_160x192_row_col(row, col, value, aux_value);
            return;
        }

        if self.display_mode == DisplayMode::NTSC || self.display_mode == DisplayMode::MONO_NTSC {
            self.draw_raw_dhires_ntsc_a2_row_col(row, col, value, aux_value);
            return;
        }

        if row < 192 && col < 40 {
            let x = col * 14;

            // Mixed mode
            if self.display_mode == DisplayMode::RGB && self.rgb_mode == 2 {
                self.draw_raw_dhires_mixed_row_col(row, col);
            } else {
                let mixed_mode = self.mixed_mode && row >= 160;
                let mut color_index = if col == 0 {
                    0
                } else if mixed_mode {
                    let val = (CHAR_APPLE2E_ROM
                        [self.read_text_memory(col - 1, row) as usize * 8 + row % 8]
                        .reverse_bits()
                        >> 3)
                        & 0xf;
                    if col % 2 == 0 {
                        val
                    } else {
                        (val & 0x3) << 2 | val >> 2
                    }
                } else {
                    let val = (self.read_hires_memory(col - 1, row) >> 3) & 0xf;
                    if col % 2 == 0 {
                        val
                    } else {
                        (val & 0x3) << 2 | val >> 2
                    }
                };

                let mut mask = 0x1;
                let mut offset = x;

                // Draw the Aux
                while mask != 0x80 {
                    let index = offset % 4;
                    if aux_value & mask > 0 {
                        color_index |= 1 << index;
                    } else {
                        color_index &= (1 << index) ^ 0xf;
                    }

                    self.set_pixel_count(offset, row * 2, DHIRES_COLORS[color_index as usize], 1);
                    mask <<= 1;
                    offset += 1;
                }

                // Draw the Main
                mask = 0x1;
                while mask != 0x80 {
                    let index = offset % 4;
                    if value & mask > 0 {
                        color_index |= 1 << index;
                    } else {
                        color_index &= (1 << index) ^ 0xf;
                    }
                    self.set_pixel_count(offset, row * 2, DHIRES_COLORS[color_index as usize], 1);
                    mask <<= 1;
                    offset += 1;
                }
            }
        }
    }

    fn draw_raw_dhires_mixed_row_col(&mut self, row: usize, col: usize) {
        if row < 192 && col < 40 {
            let x = col * 14;
            let odd = col % 2;
            let ptr = col - odd;

            let current_value = self.read_hires_memory(ptr, row);
            let current_aux_value = self.read_aux_hires_memory(ptr, row);
            let mut next_value = 0;
            let mut next_aux_value = 0;

            //
            //      Col 0             Col 1
            //   Aux      Main     Aux      Main
            // 76543210 76543210 76543210 76543210
            //  bbbaaaa  ddccccb  feeeedd  ggggfff
            //
            //
            let mut value_7_pixels =
                ((current_aux_value as u32) & 0x7f) + (((current_value as u32) & 0x7f) << 7);
            if ptr + 1 < 40 {
                next_value = self.read_hires_memory(ptr + 1, row);
                next_aux_value = self.read_aux_hires_memory(ptr + 1, row);
                value_7_pixels +=
                    (((next_aux_value as u32) & 0x7f) << 14) + (((next_value as u32) & 0x7f) << 21);
            }

            let mut color = COLOR_BLACK;
            let mut offset = 0;
            let mono_color = self.get_mono_color();

            if odd == 0 {
                if current_aux_value & 0x80 == 0 {
                    for _ in 0..7 {
                        if value_7_pixels & 1 > 0 {
                            self.set_pixel_count(x + offset, row * 2, mono_color, 1);
                        } else {
                            self.set_pixel_count(x + offset, row * 2, COLOR_BLACK, 1);
                        }
                        value_7_pixels >>= 1;
                        offset += 1;
                    }
                } else {
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 4);
                    offset += 4;
                    value_7_pixels >>= 4;
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 3);
                    offset += 3;
                    value_7_pixels >>= 3;
                }

                if current_value & 0x80 == 0 {
                    for _ in 0..7 {
                        if value_7_pixels & 1 > 0 {
                            self.set_pixel_count(x + offset, row * 2, mono_color, 1);
                        } else {
                            self.set_pixel_count(x + offset, row * 2, COLOR_BLACK, 1);
                        }
                        value_7_pixels >>= 1;
                        offset += 1;
                    }
                } else {
                    self.set_pixel_count(x + offset, row * 2, color, 1);
                    offset += 1;
                    value_7_pixels >>= 1;
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 4);
                    offset += 4;
                    value_7_pixels >>= 4;
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 2);
                }
            } else {
                if next_aux_value & 0x80 == 0 {
                    value_7_pixels >>= 14;
                    for _ in 0..7 {
                        if value_7_pixels & 1 > 0 {
                            self.set_pixel_count(x + offset, row * 2, mono_color, 1);
                        } else {
                            self.set_pixel_count(x + offset, row * 2, COLOR_BLACK, 1);
                        }
                        value_7_pixels >>= 1;
                        offset += 1;

                        if offset == 6 {
                            color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                        }
                    }
                } else {
                    value_7_pixels >>= 12;
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 2);
                    offset += 2;
                    value_7_pixels >>= 4;

                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 4);
                    offset += 4;
                    value_7_pixels >>= 4;

                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 1);
                    offset += 1;
                    value_7_pixels >>= 1;
                }

                if next_value & 0x80 == 0 {
                    for _ in 0..7 {
                        if value_7_pixels & 1 > 0 {
                            self.set_pixel_count(x + offset, row * 2, mono_color, 1);
                        } else {
                            self.set_pixel_count(x + offset, row * 2, COLOR_BLACK, 1);
                        }
                        value_7_pixels >>= 1;
                        offset += 1;
                    }
                } else {
                    self.set_pixel_count(x + offset, row * 2, color, 3);
                    offset += 3;
                    value_7_pixels >>= 3;
                    color = DHIRES_COLORS[(value_7_pixels & 0xf) as usize];
                    self.set_pixel_count(x + offset, row * 2, color, 4);
                }
            }
        }
    }

    fn draw_raw_dhires_mono_a2_row_col(
        &mut self,
        row: usize,
        col: usize,
        value: u8,
        aux_value: u8,
    ) {
        if row < 192 && col < 40 {
            let x = col * 14;
            let mut offset = 0;
            let mut mask = 0x1;

            let mono_color = self.get_mono_color();

            while mask != 0x80 {
                if aux_value & mask > 0 {
                    self.set_pixel_count(x + offset, row * 2, mono_color, 1);
                } else {
                    self.set_pixel_count(x + offset, row * 2, COLOR_BLACK, 1);
                }
                if value & mask > 0 {
                    self.set_pixel_count(x + offset + 7, row * 2, mono_color, 1);
                } else {
                    self.set_pixel_count(x + offset + 7, row * 2, COLOR_BLACK, 1);
                }
                mask <<= 1;
                offset += 1;
            }
        }
    }

    fn draw_raw_dhires_160x192_row_col(
        &mut self,
        row: usize,
        col: usize,
        _value: u8,
        _aux_value: u8,
    ) {
        if row < 192 && col < 40 {
            let x = col * 14;
            let odd = col % 2;
            let ptr = col - odd;

            let current_value = self.read_hires_memory(ptr, row);
            let current_aux_value = self.read_aux_hires_memory(ptr, row);
            let mut value_8_pixels = (current_aux_value as u32) + ((current_value as u32) << 8);
            if ptr + 1 < 40 {
                let next_value = self.read_hires_memory(ptr + 1, row);
                let next_aux_value = self.read_aux_hires_memory(ptr + 1, row);
                value_8_pixels += ((next_aux_value as u32) << 16) + ((next_value as u32) << 24);
            }

            if odd != 0 {
                value_8_pixels >>= 16;
            }

            let mut offset = 0;
            for _ in 0..4 {
                let color = LORES_COLORS[(value_8_pixels & 0xf) as usize];
                if x + offset + 3 < Video::WIDTH {
                    self.set_pixel_count(x + offset, row * 2, color, 4);
                }

                offset += 4;
                value_8_pixels >>= 4;
            }
        }
    }

    fn draw_raw_dhires_ntsc_a2_row_col(
        &mut self,
        row: usize,
        col: usize,
        value: u8,
        aux_value: u8,
    ) {
        if row < 192 && col < 40 {
            let mut luma = [0u8; 14 + 2 * NTSC_PIXEL_NEIGHBOR + 1];
            let mut offset = 0;
            let mixed_mode = self.mixed_mode && row >= 160;

            // Handle luma for col - 1
            let prev_value = if col > 0 {
                if mixed_mode {
                    CHAR_APPLE2E_ROM[self.read_text_memory(col - 1, row) as usize * 8 + row % 8]
                        .reverse_bits()
                } else {
                    self.read_hires_memory(col - 1, row)
                }
            } else {
                0
            };
            let mut mask = 1 << (7 - NTSC_PIXEL_NEIGHBOR);
            while mask != 0x80 {
                if prev_value & mask > 0 {
                    luma[offset] = 1;
                } else {
                    luma[offset] = 0;
                }
                mask <<= 1;
                offset += 1;
            }

            // Handle luma for col
            mask = 0x1;
            while mask != 0x80 {
                if aux_value & mask > 0 {
                    luma[offset] = 1;
                } else {
                    luma[offset] = 0;
                }
                if value & mask > 0 {
                    luma[offset + 7] = 1;
                } else {
                    luma[offset + 7] = 0;
                }
                mask <<= 1;
                offset += 1;
            }
            offset += 7;

            // Handle luma for col+1
            let next_value = if col < 39 {
                if mixed_mode {
                    CHAR_APPLE2E_ROM[self.read_aux_text_memory(col + 1, row) as usize * 8 + row % 8]
                        .reverse_bits()
                } else {
                    self.read_aux_hires_memory(col + 1, row)
                }
            } else {
                0
            };
            let mut mask = 0x1;
            while mask != (1 << NTSC_PIXEL_NEIGHBOR) {
                if next_value & mask > 0 {
                    luma[offset] = 1;
                } else {
                    luma[offset] = 0;
                }
                mask <<= 1;
                offset += 1;
            }

            let x = col * 14;
            for i in 0..14 {
                let pos = (x + i) % 4;
                let luma_u32 = luma_to_u32(&luma, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR);
                let mut color = self.chroma_dhgr[pos][luma_u32 as usize];

                if self.display_mode == DisplayMode::MONO_NTSC {
                    let gray =
                        (((color[0] as u16) * 30 + (color[1] as u16) * 59 + (color[2] as u16) * 11)
                            / 100) as u8;
                    color = [gray, gray, gray];
                }
                //let color = chroma_ntsc_color(&luma, x + i, NTSC_PIXEL_NEIGHBOR + i, NTSC_PIXEL_NEIGHBOR, true, &self.ntsc_decoder);
                self.set_pixel_count(x + i, 2 * row, color, 1);
            }
        }
    }
}

impl Default for Video {
    fn default() -> Self {
        Self::new()
    }
}

fn calc_lut(cycle: usize, ntsc: bool) -> usize {
    let mut visible_cycle = cycle % (CYCLES_PER_ROW * 192);
    if cycle >= CYCLES_PER_ROW * 256 {
        // VBL will scan from 0 to 0x3f after that 0x3a to 0x3f
        // for line 256 to 261, use line 0x3a to 0x3f
        visible_cycle -= 6 * CYCLES_PER_ROW;

        // For PAL system have to reduce by additional 50 lines to sync in 50Hz
        if !ntsc {
            visible_cycle -= 50 * CYCLES_PER_ROW;
        }
    }

    let mut line = visible_cycle / CYCLES_PER_ROW;
    let s = line >> 6;
    line -= s << 6;
    let q = line >> 3;
    line -= q << 3;
    let base = (line << 10) + (q << 7) + 40 * s;
    let half_page = base & 0xFF80;
    let mut a: i16 = (base + visible_cycle % CYCLES_PER_ROW) as i16 - CYCLES_PER_HBL as i16;
    if a < half_page as i16 {
        a += 0x80;
    }
    a as usize
}

fn build_lut(text_mode: bool, apple2e: bool, ntsc: bool) -> Vec<usize> {
    let mut output = if ntsc {
        vec![0; CYCLES_PER_FIELD_60HZ]
    } else {
        vec![0; CYCLES_PER_FIELD_50HZ]
    };

    for (cycle, item) in output.iter_mut().enumerate() {
        let mut offset = if text_mode {
            calc_lut(cycle, ntsc) % TEXT_LEN
        } else {
            calc_lut(cycle, ntsc) % HIRES_LEN
        };

        let col = cycle % CYCLES_PER_ROW;
        let row = cycle / CYCLES_PER_ROW;

        if col < CYCLES_PER_HBL {
            if !apple2e && text_mode {
                offset += 0x1000;
            }

            if col == 0 {
                offset += 1;
            }
        }

        if row >= 192 {
            let base2 = offset & 0xff80;
            offset &= 0x7f;
            offset = offset.wrapping_sub(8);
            offset &= 0x7f;
            offset = offset.wrapping_add(base2);
        }

        *item = offset;
    }
    output
}

#[cfg(feature = "serde_support")]
fn default_lut_text() -> Vec<usize> {
    build_lut(true, false, true)
}

#[cfg(feature = "serde_support")]
fn default_lut_text_2e() -> Vec<usize> {
    build_lut(true, true, true)
}

#[cfg(feature = "serde_support")]
fn default_lut_hires() -> Vec<usize> {
    build_lut(false, true, true)
}

#[cfg(feature = "serde_support")]
fn default_lut_text_pal() -> Vec<usize> {
    build_lut(true, false, false)
}

#[cfg(feature = "serde_support")]
fn default_lut_text_2e_pal() -> Vec<usize> {
    build_lut(true, true, false)
}

#[cfg(feature = "serde_support")]
fn default_lut_hires_pal() -> Vec<usize> {
    build_lut(false, true, false)
}

#[cfg(feature = "serde_support")]
fn default_video_cache() -> Vec<u32> {
    vec![0x00; 40 * 192]
}

#[cfg(feature = "serde_support")]
fn default_video_reparse() -> Vec<u8> {
    vec![0x00; 192]
}

#[cfg(feature = "serde_support")]
fn default_video_dirty() -> Vec<u8> {
    vec![0x00; 24]
}

#[cfg(feature = "serde_support")]
fn default_frame() -> Vec<u8> {
    vec![0xff; Video::WIDTH * Video::HEIGHT * 4]
}

fn default_ntsc_decoder() -> Vec<Yuv> {
    decoder_matrix(NTSC_LUMA_BANDWIDTH, NTSC_CHROMA_BANDWIDTH)
}

#[cfg(feature = "serde_support")]
fn default_luma_bandwidth() -> f32 {
    NTSC_LUMA_BANDWIDTH
}

#[cfg(feature = "serde_support")]
fn default_chroma_bandwidth() -> f32 {
    NTSC_CHROMA_BANDWIDTH
}

#[cfg(feature = "serde_support")]
fn default_cycle_field() -> usize {
    CYCLES_PER_FIELD_60HZ
}

#[cfg(feature = "serde_support")]
fn default_video_main() -> Vec<u8> {
    vec![0u8; 0x10000]
}

#[cfg(feature = "serde_support")]
fn default_video_aux() -> Vec<u8> {
    vec![0u8; 0x10000]
}

fn generate_chroma(ntsc_decoder: &[Yuv], dhires: bool) -> Vec<Vec<Rgb>> {
    let mut v = Vec::new();
    let bits = 1 << (2 * NTSC_PIXEL_NEIGHBOR + 1);

    for offset in 0..4 {
        let mut v1 = Vec::new();
        for i in 0..bits {
            let luma = usize_to_luma(i, NTSC_PIXEL_NEIGHBOR);
            let rgb = chroma_ntsc_color(
                &luma,
                offset + 8,
                NTSC_PIXEL_NEIGHBOR,
                NTSC_PIXEL_NEIGHBOR,
                dhires,
                ntsc_decoder,
            );
            v1.push(rgb);
        }
        v.push(v1);
    }
    v
}

fn default_chroma_hgr() -> Vec<Vec<Rgb>> {
    let ntsc_decoder = default_ntsc_decoder();
    generate_chroma(&ntsc_decoder, false)
}

fn default_chroma_dhgr() -> Vec<Vec<Rgb>> {
    let ntsc_decoder = default_ntsc_decoder();
    generate_chroma(&ntsc_decoder, true)
}

fn luma_to_u32(luma: &[u8], pos: usize, neighbor: usize) -> u32 {
    let mut mask = 0x1;
    let mut value = 0;
    for i in 0..(2 * neighbor + 1) {
        if luma[pos - neighbor + i] != 0 {
            value |= mask
        }
        mask <<= 1;
    }
    value
}

fn usize_to_luma(value: usize, neighbor: usize) -> Vec<u8> {
    let mut mask = 0x1;
    let mut v = Vec::new();
    for _ in 0..(2 * neighbor + 1) {
        if value & mask != 0 {
            v.push(1)
        } else {
            v.push(0)
        }
        mask <<= 1;
    }
    v
}

fn chroma_ntsc(luma: &[u8], x: usize, pos: usize, dhires: bool) -> Yuv {
    if luma[pos] > 0 {
        convert_chroma_to_yuv(x % 4, dhires)
    } else {
        [0.0, 0.0, 0.0]
    }
}

fn chroma_ntsc_combined(
    c: &mut Yuv,
    luma: &[u8],
    x: usize,
    pos: usize,
    offset: usize,
    dhires: bool,
    ntsc_decoder: &[Yuv],
) {
    let left = if offset > x {
        [0.0, 0.0, 0.0]
    } else {
        chroma_ntsc(luma, x - offset, pos - offset, dhires)
    };
    let right = chroma_ntsc(luma, x + offset, pos + offset, dhires);
    for i in 0..3 {
        c[i] += (left[i] + right[i]) * ntsc_decoder[offset][i]
    }
}

fn chroma_ntsc_color(
    luma: &[u8],
    x: usize,
    pos: usize,
    neighbor: usize,
    dhires: bool,
    ntsc_decoder: &[Yuv],
) -> Rgb {
    let mut c = ntsc_mul(&chroma_ntsc(luma, x, pos, dhires), &ntsc_decoder[0]);
    for i in 1..=neighbor {
        chroma_ntsc_combined(&mut c, luma, x, pos, i, dhires, ntsc_decoder);
    }
    convert_yuv_to_rgb(c)
}

#[cfg(feature = "serde_support")]
fn serialize_display_mode<S: Serializer>(
    v: &DisplayMode,
    serializer: S,
) -> Result<S::Ok, S::Error> {
    let value = match v {
        DisplayMode::NTSC => 1,
        DisplayMode::MONO_WHITE => 2,
        DisplayMode::RGB => 3,
        DisplayMode::MONO_GREEN => 4,
        DisplayMode::MONO_AMBER => 5,
        _ => 0,
    };
    usize::serialize(&value, serializer)
}

#[cfg(feature = "serde_support")]
fn deserialize_display_mode<'de, D: Deserializer<'de>>(
    deserializer: D,
) -> Result<DisplayMode, D::Error> {
    let value = match usize::deserialize(deserializer)? {
        1 => DisplayMode::NTSC,
        2 => DisplayMode::MONO_WHITE,
        3 => DisplayMode::RGB,
        4 => DisplayMode::MONO_GREEN,
        5 => DisplayMode::MONO_AMBER,
        _ => DisplayMode::DEFAULT,
    };
    Ok(value)
}

#[cfg(feature = "serde_support")]
fn deserialize_cycles<'de, D: Deserializer<'de>>(deserializer: D) -> Result<usize, D::Error> {
    let value = usize::deserialize(deserializer)? % default_cycle_field();
    Ok(value)
}
